var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S. M. Rump. Fast and Parallel Interval Arithmetic. BIT Numerical Mathematics 39, 534–554 (1999).\n\n\n\nN. Revol and P. Théveny. Parallel Implementation of Interval Matrix Multiplication. Reliable Computing 19, 91 (2013).\n\n\n\nS. Miyajima. Fast enclosure for solutions of Sylvester equations. Linear Algebra and its Applications 439, 856–878 (2013).\n\n\n\nL. Qi. Some simple estimates for singular values of a matrix. Linear Algebra and its Applications 56, 105–119 (1984).\n\n\n\nS. Miyajima. Numerical enclosure for each eigenvalue in generalized eigenvalue problem. Journal of Computational and Applied Mathematics 236, 2545–2552 (2012).\n\n\n\nS. M. Rump. Verified bounds for singular values, in particular for the spectral norm of a matrix and its inverse. BIT Numerical Mathematics 51, 367–384 (2011).\n\n\n\n","category":"page"},{"location":"references/","page":"References","title":"References","text":"N. J. Higham. Accuracy and Stability of Numerical Algorithms: Second Edition (Philadelphia, PA: SIAM, 1996).\n\n\n\nS. Miyajima. Verified bounds for all the singular values of matrix. Japan Journal of Industrial and Applied Mathematics 31, 513–539 (2014).\n\n\n\nS. M. Rump and S. Oishi. A note on Oishi’s lower bound for the smallest singular value of linearized Galerkin equations. Japan Journal of Industrial and Applied Mathematics 41, 1097–1104 (2024).\n\n\n\nS. M. Rump. Verification methods: Rigorous results using floating-point arithmetic. Acta Numerica 19, 287–449 (2010).\n\n\n\n","category":"page"},{"location":"eigenvalues/","page":"Eigenvalues","title":"Eigenvalues","text":"We are interested in algorithms to compute rigorous enclosures of eigenvalues.","category":"page"},{"location":"eigenvalues/","page":"Eigenvalues","title":"Eigenvalues","text":"We implement Ref. [5]; the idea is to approach the problem  in two steps, the interested reader may refer to the treatment in Eigenvalues in Arb for a deeper discussion on the topic.","category":"page"},{"location":"#BallArithmetic","page":"Home","title":"BallArithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BallArithmetic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package we use the tecniques first introduced in Ref. [1], following the more recent work Ref. [2] to implement a rigorous matrix product in mid-radius arithmetic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This allows to implement numerous algorithms developed by Rump, Miyajima, Ogita and collaborators to obtain a posteriori guaranteed bounds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main object are BallMatrices, i.e., midpoint matrices equipped with non-negative radii that provide rigorous entrywise enclosures.","category":"page"},{"location":"#Sylvester-equations","page":"Home","title":"Sylvester equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"sylvester_miyajima_enclosure provides a componentwise enclosure for solutions of the Sylvester equation following the fast verification method of Ref. [3].  When the data originate from an upper triangular Schur factor T, triangular_sylvester_miyajima_enclosure extracts the blocks T₁₁, T₁₂, and T₂₂, solves the associated Sylvester system T₂₂' Y₂ - Y₂ T₁₁' = T₁₂', and returns the Miyajima enclosure for the unknown block Y₂.","category":"page"},{"location":"#BallMatrix","page":"Home","title":"BallMatrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BallMatrix is the midpoint-radius companion of the scalar Ball type.  The midpoint matrix stores the approximation we would normally compute in floating-point arithmetic, whereas the radius matrix captures all sources of uncertainty (input radii, floating-point error, subnormal padding, …).  Each method documented below updates both components so the result remains a rigorous enclosure.","category":"page"},{"location":"#Constructors-and-accessors","page":"Home","title":"Constructors and accessors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The constructors delegate to the underlying BallArray to perform shape and type validation.  Working through them in order provides a tour of how the storage is organised:","category":"page"},{"location":"#Arithmetic","page":"Home","title":"Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Binary operations follow a common pattern: operate on the midpoint data as if the values were exact, then grow the radius using outward rounding. The comments inside src/types/matrix.jl walk through the steps in more detail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BallArithmetic\nA = ones((2, 2))\nbA = BallMatrix(A, A/128)\nbA^2","category":"page"},{"location":"#BallArithmetic.BallArithmetic","page":"Home","title":"BallArithmetic.BallArithmetic","text":"BallArithmetic\n\nTools for rigorous linear algebra with floating-point balls. The package builds on Ball numbers—midpoint/radius pairs that track rounding error—to provide array, matrix, and vector types with propagated uncertainty. High-level routines such as norm bounds, eigenvalue certification, and singular value enclosures are exposed via this module after it has been loaded.\n\nMost functionality is available through exported symbols documented in the respective source files. Loading the module also enables auxiliary utilities such as rigorous rounding macros and promotion rules that let Ball values interact seamlessly with base Julia numeric types.\n\n\n\n\n\n","category":"module"},{"location":"#BallArithmetic.η","page":"Home","title":"BallArithmetic.η","text":"η\n\nSmallest positive subnormal Float64 value. Adding η to a computed radius guarantees that results remain strictly positive even in edge cases where an operation underflows to zero.\n\n\n\n\n\n","category":"constant"},{"location":"#BallArithmetic.ϵp","page":"Home","title":"BallArithmetic.ϵp","text":"ϵp\n\nUnit roundoff for Float64 values. The constant represents the maximum relative error introduced by a single rounded floating-point operation and is used throughout the package when inflating radii after computations.\n\n\n\n\n\n","category":"constant"},{"location":"#BallArithmetic.Ball","page":"Home","title":"BallArithmetic.Ball","text":"Ball{T, CT}\n\nClosed floating-point ball with midpoint type CT and radius type T. Each value represents the set { c + δ : |δ| ≤ r } where c::CT is the stored midpoint and r::T ≥ 0 is the radius. Both real and complex midpoints are supported as long as the radius is expressed in the underlying real field. The type behaves as a number and participates in arithmetic with rigorous outward rounding.\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.Ball-Tuple{Any, Any}","page":"Home","title":"BallArithmetic.Ball","text":"Ball(c, r)\n\nConstruct a ball whose midpoint is c and radius is r. Both arguments are converted to floating-point values so that subsequent arithmetic obeys the package's rounding assumptions.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.Ball-Tuple{Ball}","page":"Home","title":"BallArithmetic.Ball","text":"Ball(x::Ball)\n\nIdentity conversion that returns x unchanged. This overload allows Ball to participate seamlessly in generic code that may attempt to reconstruct elements via the type constructor.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.Ball-Tuple{T} where T<:Number","page":"Home","title":"BallArithmetic.Ball","text":"Ball(c::Number)\n\nCreate a degenerate ball representing the exact value c. The midpoint is stored as float(c) and the radius is zero.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.BallArray","page":"Home","title":"BallArithmetic.BallArray","text":"BallArray{T, N, NT, BT, CA, RA}\n\nMulti-dimensional array whose entries are Ball values. The type stores midpoint data c::CA and radius data r::RA separately while presenting an AbstractArray{BT, N} interface that behaves like an array of balls. The parameters mirror the element type and storage layout and are inferred automatically from the provided midpoint and radius containers.\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.BallArray-Tuple{AbstractArray}","page":"Home","title":"BallArithmetic.BallArray","text":"BallArray(A::AbstractArray)\n\nWrap an array of midpoints A into a BallArray with zero radii. This is equivalent to calling BallArray(mid(A), rad(A)) and is particularly useful when upgrading an existing numeric array to a rigorous enclosure.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.BallMatrix","page":"Home","title":"BallArithmetic.BallMatrix","text":"BallMatrix{T, NT, BT, CM, RM}\n\nAlias for the two-dimensional BallArray used to represent matrices with rigorous error control. The type parameters mirror those of BallArray and describe the base floating-point type T, the element type NT, the Ball container BT, and the concrete matrix types used for the midpoints (CM) and radii (RM).\n\nUsers typically construct instances through the BallMatrix constructors below rather than specifying these parameters explicitly.\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.BallMatrix-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"BallArithmetic.BallMatrix","text":"BallMatrix(c::AbstractMatrix, r::AbstractMatrix)\n\nCreate a BallMatrix from a matrix of midpoints c and a matrix of non-negative radii r. Each entry of the resulting BallMatrix contains the ball c[i, j] ± r[i, j].\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.BallMatrix-Tuple{AbstractMatrix}","page":"Home","title":"BallArithmetic.BallMatrix","text":"BallMatrix(M::AbstractMatrix)\n\nCreate a BallMatrix from an existing matrix of midpoint values. The radius of every entry defaults to zero, corresponding to exact entries.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.BallVector","page":"Home","title":"BallArithmetic.BallVector","text":"BallVector{T, NT, BT, CM, RM}\n\nAlias for the one-dimensional BallArray, representing vectors of balls.\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.BallVector-Tuple{AbstractVector, AbstractVector}","page":"Home","title":"BallArithmetic.BallVector","text":"BallVector(c::AbstractVector, r::AbstractVector)\n\nConstruct a BallVector from matching midpoint and radius arrays.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.BallVector-Tuple{AbstractVector}","page":"Home","title":"BallArithmetic.BallVector","text":"BallVector(v::AbstractVector)\n\nWrap a vector of midpoints into a BallVector with zero radii.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.MiyajimaVBDResult","page":"Home","title":"BallArithmetic.MiyajimaVBDResult","text":"MiyajimaVBDResult\n\nContainer returned by miyajima_vbd encapsulating the data produced by the verified block diagonalisation (VBD) step. The fields contain the basis that block diagonalises the midpoint matrix, the transformed enclosure, its block-diagonal truncation, the rigorous remainder, and the Gershgorin clusters that certify how the spectrum groups together.\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.RigorousEigenvaluesResult","page":"Home","title":"BallArithmetic.RigorousEigenvaluesResult","text":"RigorousEigenvaluesResult\n\nContainer returned by rigorous_eigenvalues bundling the midpoint eigenvector factorisation, the certified eigenvalue enclosures, and the norm bounds underpinning their verification. Besides behaving like the underlying vector of eigenvalue balls, the struct exposes the interval residual, the projected residual used in the Miyajima certification, and the inverse defect (inverse * vectors - I).\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.RigorousGeneralizedEigenvaluesResult","page":"Home","title":"BallArithmetic.RigorousGeneralizedEigenvaluesResult","text":"RigorousGeneralizedEigenvaluesResult\n\nContainer returned by rigorous_generalized_eigenvalues bundling the midpoint eigenvector factorisation, the certified eigenvalue enclosures, and the norm bounds underpinning their verification. Besides behaving like the underlying vector of eigenvalue balls, the struct exposes the interval residual, the projected residual used in the Miyajima certification, and the coupling defect of the left action (left_action * B * right_vectors - I).\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.RigorousSVDResult","page":"Home","title":"BallArithmetic.RigorousSVDResult","text":"RigorousSVDResult\n\nContainer returned by rigorous_svd bundling the midpoint factorisation, the certified singular-value enclosures, and the block-diagonal refinement obtained from miyajima_vbd.  Besides the singular values themselves the struct exposes the residual and orthogonality defect bounds that underpin the certification.\n\n\n\n\n\n","category":"type"},{"location":"#BallArithmetic.:±-Tuple{Any, Any}","page":"Home","title":"BallArithmetic.:±","text":"±(c, r)\n\nShorthand constructor for Ball(c, r). The operator mirrors the common mathematical notation c ± r for centered intervals.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic._ccr-Union{Tuple{T}, Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, Type{T}}} where T<:AbstractFloat","page":"Home","title":"BallArithmetic._ccr","text":"_ccr(Hrl, Hru, Hil, Hiu, ::Type{T}) where {T<:AbstractFloat}\n\nCollapse rectangular enclosures for Re(F*G) and Im(F*G) to a complex ball enclosure BallMatrix(Hc, Hr).\n\nCenters are midpoints Rc = (Hru+Hrl)/2, Ic = (Hiu+Hil)/2 computed with RoundNearest. Radii are the outward 2-norm of the half-widths: Hr = sqrt(((Hru-Hrl)/2).^2 + ((Hiu-Hil)/2).^2) computed with RoundUp.\n\nThis implements the ball conversion step used with the Oishi–Rump rounding-mode controlled product.\n\nReference:\n\n“Fast enclosure of matrix eigenvalues and singular values via rounding mode controlled computation,” Linear Algebra and its Applications 324 (2001), 133–146.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic._compute_exclusion_circle_level_set_priori-Tuple{Any, Any, Any}","page":"Home","title":"BallArithmetic._compute_exclusion_circle_level_set_priori","text":"_compute_exclusion_circle_level_set_priori(T,\nλ,\nϵ;\nrel_pearl_size,\nmax_initial_newton)\n\nThis method bounds the resolvent on a circle centered at λ that intersects in at least one point z0 the ϵ level set. This intersection is found by a Newton step, and fixes the radius of the circle,\n\nThe value of rel_pearl_size gives us the relative radius of the pearls with respect to the radius of the circle\n\nSome rule of thumbs for the number of SVD computations: if relpearlsize is 1/32, we are going to compute and certify 160 svds, if relpearlsize is 1/64 we are going to compute and certify 320 svds. In other words, the time of the computation scales linearly with the quality of the pearl necklace\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic._oishi_MMul_up_lo-Tuple{AbstractMatrix{<:Complex}, AbstractMatrix{<:Complex}}","page":"Home","title":"BallArithmetic._oishi_MMul_up_lo","text":"_oishi_MMul_up_lo(F::AbstractMatrix{<:Complex}, G::AbstractMatrix{<:Complex})\n\nCompute outward lower/upper enclosures for the real and imaginary parts of the complex matrix product F*G using directed-rounding (rounding-mode controlled) evaluation in the sense of Oishi–Rump.\n\nReturns (Hrl, Hru, Hil, Hiu, T), where Hrl ≤ Re(F*G) ≤ Hru and Hil ≤ Im(F*G) ≤ Hiu hold entrywise, and T is the promoted underlying real working type.\n\nPromotion follows T = promote_type(float(real(eltype(F))), float(real(eltype(G)))). For mathematical correctness, T must honor setrounding (e.g., BigFloat).\n\nReference:\n\n“Fast enclosure of matrix eigenvalues and singular values via rounding mode controlled computation,” Linear Algebra and its Applications 324 (2001), 133–146.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic._triangularize-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic._triangularize","text":"_triangularize(A::BallMatrix)\n\nReturn an upper-triangular BallMatrix enclosure by wrapping the stored midpoint and radius matrices in UpperTriangular. This helper is used by algorithms that operate on triangular factors while keeping the original enclosure guarantees.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic._upper_bound_norm","page":"Home","title":"BallArithmetic._upper_bound_norm","text":"_upper_bound_norm(center, radius, p)\n\nInternal helper that computes a rigorous upper bound on the p-norm of an array represented by separate midpoint center and radius radius arrays. The function evaluates the norm of both parts with rounding directed upward and adds the results to preserve an enclosure.\n\n\n\n\n\n","category":"function"},{"location":"#BallArithmetic.ball_hull-Union{Tuple{T}, Tuple{Ball{T, T}, Ball{T, T}}} where T","page":"Home","title":"BallArithmetic.ball_hull","text":"ball_hull(a::Ball, b::Ball)\n\nReturn the smallest ball that contains both a and b. For real centres the function encloses the convex hull on the real line. When the midpoints are complex the result encloses both discs while keeping the centre as close as possible to one of the inputs so that subsequent operations remain stable.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.collatz_upper_bound_L2_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.collatz_upper_bound_L2_opnorm","text":"collatz_upper_bound_L2_opnorm(A::BallMatrix; iterates=10)\n\nGive a rigorous upper bound on the ℓ² norm of the matrix A by using the Collatz theorem.\n\nWe use Perron theory here: if for two matrices with B positive |A| < B we have ρ(A)<=ρ(B) by Wielandt's theorem Wielandt's theorem\n\nThe keyword argument iterates is used to establish how many times we are iterating the vector of ones before we use Collatz's estimate.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.compute_enclosure-Tuple{BallMatrix, Any, Any, Any}","page":"Home","title":"BallArithmetic.compute_enclosure","text":"compute_enclosure(A::BallMatrix, r1, r2, ϵ; max_initial_newton = 30,\n        max_steps = Int64(ceil(256 * π)), rel_steps = 16)\n\nGiven a BallMatrix `A`, this method follows the level lines of level `ϵ`\n\naround the eigenvalues with modulus bound between r1 and r2.\n\nThe keyword arguments     - maxinitialnewton: maximum number of newton steps to reach the level lines     - maxsteps: maximum number of steps following the contour     - relsteps: relative integration step for the Euler method\n\nThe method outputs an array of truples:     - the first element is the eigenvalue we are enclosing     (in the case of the excluding circles, it is 0.0 or the maximum modulus of the eigenvalues)     - the second element is an upper bound on the resolvent norm     - the third element is a list of points on the enclosing line; the resolvent is rigorously     bound on circles centered at each point and of radius 5/8 the distance to the previous point\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.diagonal_abs_lower_bound-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.diagonal_abs_lower_bound","text":"Computes a vector containing lower bounds for the diagonal elements of |A|\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.epsilon_inflation-Union{Tuple{T}, Tuple{BallMatrix{T}, BallVector{T}}} where T<:AbstractFloat","page":"Home","title":"BallArithmetic.epsilon_inflation","text":"epsilon_inflation(A::BallMatrix{T}, b::BallVector{T};\n                  r=0.1, ϵ=1e-20, iter_max=20) where {T<:AbstractFloat}\n\nGives an enclosure of the solution of the square linear system Ax=b using the ϵ-inflation algorithm,  see algorithm 10.7 of\n\nInput\n\nA        – square matrix of size n × n\nb        – vector of length n or matrix of size n × m\nr        – relative inflation, default 10%\nϵ        – absolute inflation, default 1e-20\niter_max – maximum number of iterations\n\nOutput\n\nx    – enclosure of the solution of the linear system\ncert – Boolean flag, if cert==true, then x is certified to contain the true\n\nsolution of the linear system, if cert==false, then the algorithm could not prove that x actually contains the true solution.\n\nAlgorithm\n\nGiven the real system Ax=b and an approximate solution ̃x, we initialize x₀ = ̃x ̃x. At each iteration the algorithm computes the inflation\n\ny = xₖ * 1 - r 1 + r + -ϵ ϵ\n\nand the update\n\nxₖ₁ = Z + (I - CA)y,\n\nwhere Z = C(b - Ax₀) and C is an approximate inverse of A. If the condition xₖ₁  y is met, then xₖ₁ is a proved enclosure of A¹b and cert is set to true. If the condition is not met by the maximum number of iterations, the latest computed enclosure is returned, but cert is set to false, meaning the algorithm could not prove that the enclosure contains the true solution. For interval systems, ̃x is obtained considering the midpoint of A and b.\n\nNotes\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.evbox-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.evbox","text":"evbox(A::BallMatrix{T})\n\nBackward-compatible wrapper returning only the vector of eigenvalue enclosures produced by rigorous_eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.gevbox-Union{Tuple{T}, Tuple{BallMatrix{T}, BallMatrix{T}}} where T","page":"Home","title":"BallArithmetic.gevbox","text":"gevbox(A::BallMatrix{T}, B::BallMatrix{T})\n\nBackward-compatible wrapper returning only the vector of eigenvalue enclosures produced by rigorous_generalized_eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.inf-Tuple{Ball}","page":"Home","title":"BallArithmetic.inf","text":"inf(x::Ball)\n\nReturn the infimum (lower endpoint) of the set represented by x by evaluating mid(x) - rad(x) with downward rounding.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.intersect_ball-Union{Tuple{T}, Tuple{Ball{T, T}, Ball{T, T}}} where T","page":"Home","title":"BallArithmetic.intersect_ball","text":"intersect_ball(a::Ball, b::Ball)\n\nReturn the intersection of the real balls a and b. When the balls do not overlap the function returns nothing to indicate that the intersection is empty.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.is_M_matrix-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.is_M_matrix","text":"Rigorous computer assisted proof of the fact that a matrix is an M-matrix\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.mid-Tuple{AbstractArray}","page":"Home","title":"BallArithmetic.mid","text":"mid(A::AbstractArray)\n\nFallback definition that treats ordinary arrays as their own midpoint representation. Specialisations for BallArray overload this method to return the stored midpoint data.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.mid-Tuple{AbstractMatrix}","page":"Home","title":"BallArithmetic.mid","text":"mid(A::AbstractMatrix)\n\nReturn the midpoint matrix associated with A. For plain matrices the midpoint equals the matrix itself; for BallMatrix values this method is extended elsewhere to extract the stored midpoint data.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.mid-Tuple{AbstractVector}","page":"Home","title":"BallArithmetic.mid","text":"mid(v::AbstractVector)\n\nTreat ordinary vectors as their own midpoints.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.mid-Tuple{BallArray}","page":"Home","title":"BallArithmetic.mid","text":"mid(A::BallArray)\n\nReturn the stored midpoint array.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.mid-Tuple{Ball}","page":"Home","title":"BallArithmetic.mid","text":"mid(x)\n\nReturn the midpoint of x. For plain numbers the midpoint is the value itself, while for balls the stored center is returned.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.midtype-Union{Tuple{Ball{T, CT}}, Tuple{CT}, Tuple{T}} where {T, CT}","page":"Home","title":"BallArithmetic.midtype","text":"midtype(::Ball)\n\nReturn the type used to store the midpoint component of a Ball. This is useful for allocating arrays that mirror the internal layout of a ball or a collection of balls.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.miyajima_vbd-Union{Tuple{BallMatrix{T, NT}}, Tuple{NT}, Tuple{T}} where {T, NT}","page":"Home","title":"BallArithmetic.miyajima_vbd","text":"miyajima_vbd(A::BallMatrix; hermitian = false)\n\nPerform Miyajima's verified block diagonalisation (VBD) on the square ball matrix A.  The midpoint matrix is reduced either by an eigenvalue decomposition (when hermitian = true) or by a unitary Schur form (for the general case).  The enclosure is transported to that basis, the Gershgorin discs are clustered, and a block-diagonal truncation together with a rigorous remainder is produced.\n\nOverlapping discs are grouped via their connectivity graph so that each cluster becomes contiguous after a basis permutation.  The remainder bound combines the classical Collatz estimate with a block-separation bound that exploits the verified gaps between clusters.\n\nWhen hermitian = true the routine expects A to be Hermitian and the resulting eigenvalues and intervals are real.  Otherwise the Schur form is used and the clusters are discs in the complex plane.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.off_diagonal_abs-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.off_diagonal_abs","text":"Returns a matrix containing the off-diagonal elements\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.oishi_MMul-Tuple{Any, Any}","page":"Home","title":"BallArithmetic.oishi_MMul","text":"oishi_MMul(F, G)\n\nHigh-level wrapper: compute a complex ball enclosure of the product F*G via the Oishi–Rump rounding-mode controlled method. Internally calls _oishi_MMul_up_lo to get componentwise rectangular bounds, then _ccr to convert them into a BallMatrix.\n\nReference:\n\n“Fast enclosure of matrix eigenvalues and singular values via rounding mode controlled computation,” Linear Algebra and its Applications 324 (2001), 133–146.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.qi_intervals-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.qi_intervals","text":"qi_intervals(A::BallMatrix)\n\nQi (1984, Theorem 2) intervals for singular values. Returns the intervals Bᵢ as a Vector{Ball}. See Ref. [4].\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.qi_intervals_rebalanced-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.qi_intervals_rebalanced","text":"qi_intervals_rebalanced(A::BallMatrix)\n\nQi (1984, Theorem 2) intervals after the balancing transformation suggested in the paper. See Ref. [4].\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.qi_sqrt_intervals-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.qi_sqrt_intervals","text":"qi_sqrt_intervals(A::BallMatrix)\n\nSharper square-root intervals for the singular values (Qi 1984, Theorem 3). See Ref. [4].\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.qi_sqrt_intervals_rebalanced-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.qi_sqrt_intervals_rebalanced","text":"qi_sqrt_intervals_rebalanced(A::BallMatrix)\n\nQi (1984, Theorem 3) square-root intervals after the balancing transformation suggested in the paper. See Ref. [4].\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rad-Tuple{BallArray}","page":"Home","title":"BallArithmetic.rad","text":"rad(A::BallArray)\n\nReturn the stored radius array.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rad-Tuple{Ball}","page":"Home","title":"BallArithmetic.rad","text":"rad(x)\n\nReturn the radius associated with x. Numbers default to a zero radius, and balls return their stored uncertainty.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rad-Union{Tuple{AbstractArray{Complex{T}, 2}}, Tuple{T}} where T<:AbstractFloat","page":"Home","title":"BallArithmetic.rad","text":"rad(A::AbstractMatrix{Complex{T}})\n\nReturn a matrix of real radii matching the size of the complex matrix A. Even for complex entries the radius is measured over the underlying real field, hence the resulting matrix has element type T.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rad-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T<:AbstractFloat","page":"Home","title":"BallArithmetic.rad","text":"rad(A::AbstractArray)\n\nReturn a zero array of matching size that serves as the default radius for non-ball arrays.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rad-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:AbstractFloat","page":"Home","title":"BallArithmetic.rad","text":"rad(A::AbstractMatrix{T})\n\nReturn a matrix of radii matching the size of A. For non-ball matrices this defaults to a zero matrix, while for BallMatrix values the method is overloaded to provide the stored uncertainty information.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rad-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractFloat","page":"Home","title":"BallArithmetic.rad","text":"rad(v::AbstractVector)\n\nDefault radius for non-ball vectors: a zero vector of the appropriate floating-point type.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.radtype-Union{Tuple{Ball{T, CT}}, Tuple{CT}, Tuple{T}} where {T, CT}","page":"Home","title":"BallArithmetic.radtype","text":"radtype(x)\n\nReturn the floating-point type used to store radii for x. The helper accepts either a ball instance or the associated type, mirroring the behaviour of midtype.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rigorous_eigenvalues-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.rigorous_eigenvalues","text":"rigorous_eigenvalues(A::BallMatrix)\n\nCompute rigorous enclosures for the eigenvalues of A, following Ref. [5].  The returned RigorousEigenvaluesResult exposes both the interval enclosures and the norm bounds used during certification.\n\nTODO: Using Miyajima's algorithm is overkill, may be worth using\n\nReferences\n\n[5] Miyajima, JCAM 246, 9 (2012)\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rigorous_generalized_eigenvalues-Union{Tuple{T}, Tuple{BallMatrix{T}, BallMatrix{T}}} where T","page":"Home","title":"BallArithmetic.rigorous_generalized_eigenvalues","text":"rigorous_generalized_eigenvalues(A::BallMatrix, B::BallMatrix)\n\nCompute rigorous enclosures for the eigenvalues of the generalised problem A * x = λ * B * x, following Ref. [5].  The returned RigorousGeneralizedEigenvaluesResult exposes both the interval enclosures and the norm bounds used during certification.\n\nReferences\n\n[5] Miyajima, JCAM 246, 9 (2012)\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.rigorous_svd-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.rigorous_svd","text":"rigorous_svd(A::BallMatrix; apply_vbd = true)\n\nCompute a rigorous singular value decomposition of the ball matrix A. The midpoint SVD is certified following Theorem 3.1 of Ref. [6]; optionally, the resulting singular-value enclosure can be refined by applying miyajima_vbd to Σ'Σ, yielding a block-diagonal structure with a rigorously bounded remainder.\n\nThe returned RigorousSVDResult exposes both the enclosures and the intermediate norm bounds that justify them. When apply_vbd is set to false, the block_diagonalisation field is nothing.\n\nReferences\n\n[6] Rump S., BIT 51, 2 (2011)\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.sup-Tuple{Ball}","page":"Home","title":"BallArithmetic.sup","text":"sup(x::Ball)\n\nReturn the supremum (upper endpoint) of the set represented by x by evaluating mid(x) + rad(x) with outward rounding.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svd_bound_L2_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.svd_bound_L2_opnorm","text":"svd_bound_L2_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ²-norm of the ball matrix A using the rigorous enclosure for the singular values implemented in svd/svd.jl\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svd_bound_L2_opnorm_inverse-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.svd_bound_L2_opnorm_inverse","text":"svd_bound_L2_opnorm_inverse(A::BallMatrix)\n\nReturns a rigorous upper bound on the ℓ²-norm of the inverse of the ball matrix A using the rigorous enclosure for the singular values implemented in svd/svd.jl\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svd_bound_L2_resolvent-Tuple{BallMatrix, Ball}","page":"Home","title":"BallArithmetic.svd_bound_L2_resolvent","text":"svd_bound_L2_resolvent(A::BallMatrix, lam::Ball)\n\nReturns a rigorous upper bound on the ℓ²-norm of the resolvent of A at λ, i.e., ||(A-λ)^{-1}||_{ℓ²}\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svdbox-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.svdbox","text":"svdbox(A::BallMatrix; apply_vbd = true)\n\nBackward-compatible wrapper returning only the vector of singular-value enclosures produced by rigorous_svd.  New code should prefer rigorous_svd directly to access the additional certification data.  The optional apply_vbd flag mirrors the one in rigorous_svd.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.sylvester_miyajima_enclosure-NTuple{4, AbstractMatrix}","page":"Home","title":"BallArithmetic.sylvester_miyajima_enclosure","text":"sylvester_miyajima_enclosure(A, B, C, X̃)\n\nCompute a Miyajima-style verified enclosure for the solution of the Sylvester problem A * X + X * B = C.  The method follows the componentwise certificate from Ref. [3] and returns a BallMatrix whose midpoint is the supplied approximation X̃ and whose radii enclose the exact solution entrywise.\n\nThe routine raises an error when the spectral gaps λ_i(A) + λ_j(B) vanish or when the contraction bound is not satisfied.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.triangular_sylvester_miyajima_enclosure-Tuple{AbstractMatrix, Integer}","page":"Home","title":"BallArithmetic.triangular_sylvester_miyajima_enclosure","text":"triangular_sylvester_miyajima_enclosure(T, k)\n\nConstruct the Miyajima enclosure for the Sylvester system associated with the upper-triangular matrix T partitioned as\n\nT = [T₁₁  T₁₂;\n     0    T₂₂],\n\nwhere T₁₁ is k × k.  The enclosure is computed for the solution Y₂ of the transformed Sylvester equation T₂₂' * Y₂ - Y₂ * T₁₁' = T₁₂'.  Forming the standard Sylvester data A = T₂₂', B = -T₁₁', and C = T₁₂', the routine solves for an approximate Y₂ and then calls sylvester_miyajima_enclosure to obtain a verified bound.  The returned BallMatrix encloses the exact Y₂ entrywise.\n\nThe matrix T must be square and upper triangular, and the block size k must satisfy 1 ≤ k < size(T, 1).\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_abs-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_abs","text":"upper_abs(A)\n\nReturn a floating point matrix B whose entries are bigger or equal (componentwise) any of the entries of A\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_L1_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_bound_L1_opnorm","text":"upper_bound_L1_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ¹-norm of the ball matrix A\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_L2_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_bound_L2_opnorm","text":"upper_bound_L_inf_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ²-norm of the ball matrix A using the best between the Collatz bound and the interpolation bound\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_L_inf_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_bound_L_inf_opnorm","text":"upper_bound_L_inf_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ-∞-norm of the ball matrix A\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_norm","page":"Home","title":"BallArithmetic.upper_bound_norm","text":"upper_bound_norm(v::BallVector, p::Real = 2)\n\nCompute a rigorous upper bound for the p-norm of a BallVector.\n\n\n\n\n\n","category":"function"},{"location":"#BallArithmetic.upper_bound_norm-2","page":"Home","title":"BallArithmetic.upper_bound_norm","text":"upper_bound_norm(A::BallMatrix, p::Real = 2)\n\nCompute a rigorous upper bound for the p-norm of a BallMatrix by delegating to _upper_bound_norm on the stored midpoint and radius arrays. The default p = 2 corresponds to the Frobenius norm.\n\n\n\n\n\n","category":"function"},{"location":"#Base.:*-Tuple{AbstractMatrix, BallVector}","page":"Home","title":"Base.:*","text":"*(A::AbstractMatrix, v::BallVector)\n\nPromote a plain matrix to a BallMatrix before multiplying it with a ball vector.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{Ball, Ball}","page":"Home","title":"Base.:*","text":"*(x::Ball, y::Ball)\n\nMultiply two balls and return the enclosure of the product. The midpoint is the product of the midpoints, whereas the radius collects propagated uncertainty from both operands and the intrinsic rounding error of the operation.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{BallMatrix, BallVector}","page":"Home","title":"Base.:*","text":"*(A::BallMatrix, v::BallVector)\n\nMultiply a ball matrix with a ball vector. The vector is reshaped into a column matrix so that the existing BallMatrix multiplication handles the enclosure bookkeeping.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{BallMatrix, Vector}","page":"Home","title":"Base.:*","text":"*(A::BallMatrix, v::AbstractVector)\n\nMultiply a ball matrix with a plain vector by promoting the vector to a column BallMatrix and reusing the matrix-matrix multiplication kernel.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{NT}, Tuple{T}, Tuple{Ball{T, NT}, BallMatrix{T}}} where {T, NT<:Union{Complex{T}, T}}","page":"Home","title":"Base.:*","text":"*(λ::Ball, A::BallMatrix)\n\nScale A by a scalar Ball. The midpoint is scaled by the midpoint of λ and the radius is enlarged to account for both the uncertainty in λ and floating-point rounding.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{NT}, Tuple{T}, Tuple{Ball{T, NT}, BallVector{T}}} where {T, NT<:Union{Complex{T}, T}}","page":"Home","title":"Base.:*","text":"*(λ::Ball, v::BallVector)\n\nScale a ball vector by a ball-valued scalar, combining the uncertainty in both arguments.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{BallArray{T, 2, Complex{T}, BT, CM, RM} where {BT, CM, RM}, BallArray{T, 2, Complex{T}, BT, CM, RM} where {BT, CM, RM}}} where T<:AbstractFloat","page":"Home","title":"Base.:*","text":"*(A::BallMatrix{T, Complex{T}}, B::BallMatrix{T, Complex{T}})\n\nMultiply two complex BallMatrix values. The product is formed by combining the real and imaginary parts via the previously defined real matrix multiplications.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{BallArray{T, 2, Complex{T}, BT, CM, RM} where {BT, CM, RM}, BallMatrix{T, T}}} where T<:AbstractFloat","page":"Home","title":"Base.:*","text":"*(A::BallMatrix{T, Complex{T}}, B::BallMatrix{T, T})\n\nMultiply a complex BallMatrix by a real one by dispatching to the real and imaginary parts separately.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{BallMatrix{T, T}, BallArray{T, 2, Complex{T}, BT, CM, RM} where {BT, CM, RM}}} where T<:AbstractFloat","page":"Home","title":"Base.:*","text":"*(A::BallMatrix{T, T}, B::BallMatrix{T, Complex{T}})\n\nMultiply a real BallMatrix by a complex one, computing the product of midpoint matrices componentwise and rigorously propagating the radii.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{Number, BallMatrix{T}}} where T","page":"Home","title":"Base.:*","text":"*(λ::Number, A::BallMatrix)\n\nScale the BallMatrix A by the scalar λ. Both the midpoint and the radius are scaled, and an outward-rounded padding proportional to floating-point error is added so the result remains a rigorous enclosure.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{Number, BallVector{T}}} where T","page":"Home","title":"Base.:*","text":"*(λ::Number, v::BallVector)\n\nScale a ball vector by a scalar. The midpoint is scaled directly while the radius accounts for propagated uncertainty and roundoff.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{S}, Tuple{AbstractMatrix{S}, BallMatrix{T, S}}} where {S, T<:AbstractFloat}","page":"Home","title":"Base.:*","text":"*(A::AbstractMatrix, B::BallMatrix)\n\nMultiply an arbitrary dense or structured matrix with a BallMatrix. The enclosure of the result is obtained using the same rigorous matrix multiplication kernel as in the purely ball-valued case.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{S}, Tuple{BallMatrix{T, S}, AbstractMatrix{S}}} where {S, T<:AbstractFloat}","page":"Home","title":"Base.:*","text":"*(A::BallMatrix, B::AbstractMatrix)\n\nMultiply a BallMatrix by an arbitrary dense or structured matrix, propagating the midpoint product and rigorously bounding the resulting radii.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{S}, Tuple{BallMatrix{T, S}, BallMatrix{T, S}}} where {S, T<:AbstractFloat}","page":"Home","title":"Base.:*","text":"*(A::BallMatrix, B::BallMatrix)\n\nMultiply two compatible BallMatrix values using the rigorously rounded matrix multiplication kernels provided in the MMul submodule.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Ball, Ball}","page":"Home","title":"Base.:+","text":"Base.:+(x::Ball, y::Ball)\n\nCombine two balls using addition and enlarge the radius so that the result remains a rigorous enclosure. The midpoint is the rounded sum and the radius accounts for both operands plus floating-point roundoff.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Ball}","page":"Home","title":"Base.:+","text":"+(x::Ball)\n\nReturn x unchanged. Unary plus exists for completeness so that generic numeric code can treat balls like other scalar types.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{LinearAlgebra.UniformScaling, BallMatrix}","page":"Home","title":"Base.:+","text":"+(J::UniformScaling, A::BallMatrix)\n\nSymmetric counterpart to +(::BallMatrix, ::UniformScaling), allowing the uniform scaling to appear on the left-hand side.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{NT}, Tuple{T}, Tuple{BallMatrix{T}, LinearAlgebra.UniformScaling{Ball{T, NT}}}} where {T, NT<:Union{Complex{T}, T}}","page":"Home","title":"Base.:+","text":"+(A::BallMatrix, J::UniformScaling{Ball})\n\nAdd a ball-valued UniformScaling to a BallMatrix, incorporating both the midpoint and the radius of the scaling into the resulting enclosure.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{AbstractMatrix{T}, BallMatrix{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:+","text":"Base.:+(B::AbstractMatrix, A::BallMatrix)\n\nCommutative counterpart of +(::BallMatrix, ::AbstractMatrix), allowing the plain matrix to appear on the left-hand side.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{BallMatrix{T}, AbstractMatrix{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:+","text":"Base.:+(A::BallMatrix, B::AbstractMatrix)\n\nAdd a plain matrix to a BallMatrix by combining the midpoints directly and inflating the radii to account for the existing uncertainty in A and the floating-point error introduced by the addition.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{BallMatrix{T}, BallMatrix{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:+","text":"Base.:+(A::BallMatrix, B::BallMatrix)\n\nCombine two BallMatrix values elementwise using addition while tracking floating-point and enclosure errors. The midpoint matrices are added directly and the radii are enlarged using outward rounding to maintain a rigorous enclosure.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{BallMatrix{T}, LinearAlgebra.UniformScaling}} where T","page":"Home","title":"Base.:+","text":"+(A::BallMatrix, J::UniformScaling)\n\nAdd a UniformScaling operator (such as I) to a square BallMatrix. The diagonal of the midpoint is shifted by J and the corresponding radii are enlarged to maintain a valid enclosure.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{BallVector{T}, BallVector{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:+","text":"Base.:+(A::BallVector, B::BallVector)\n\nCombine two ball vectors elementwise using addition, enlarging the radius to include roundoff and the uncertainties of both operands.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{Ball, Ball}","page":"Home","title":"Base.:-","text":"Base.:-(x::Ball, y::Ball)\n\nCombine two balls using subtraction and enlarge the radius so that the result remains a rigorous enclosure. The midpoint is the rounded difference and the radius accounts for both operands plus floating-point roundoff.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{Ball}","page":"Home","title":"Base.:-","text":"-(x::Ball)\n\nNegate the midpoint of x while keeping the radius unchanged. The result encloses the additive inverse of the represented set.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{NT}, Tuple{T}, Tuple{BallMatrix{T}, LinearAlgebra.UniformScaling{Ball{T, NT}}}} where {T, NT<:Union{Complex{T}, T}}","page":"Home","title":"Base.:-","text":"-(A::BallMatrix, J::UniformScaling{Ball})\n\nSubtract a ball-valued UniformScaling from a BallMatrix, accounting for both the midpoint and radius of the scaling in the resulting enclosure.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{NT}, Tuple{T}, Tuple{LinearAlgebra.UniformScaling{Ball{T, NT}}, BallMatrix{T}}} where {T, NT<:Union{Complex{T}, T}}","page":"Home","title":"Base.:-","text":"-(J::UniformScaling{Ball}, A::BallMatrix)\n\nSubtract a BallMatrix from a ball-valued uniform scaling operator, expanding the resulting radii by both the uncertainty in J and the rounding performed during the subtraction.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{AbstractMatrix{T}, BallMatrix{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:-","text":"Base.:-(B::AbstractMatrix, A::BallMatrix)\n\nSubtract a BallMatrix from a plain matrix, reusing the implementation of -(::BallMatrix, ::AbstractMatrix) by swapping the argument order.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{BallMatrix{T}, AbstractMatrix{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:-","text":"Base.:-(A::BallMatrix, B::AbstractMatrix)\n\nSubtract a plain matrix from a BallMatrix. The midpoint subtraction is performed elementwise while the radius is enlarged to remain enclosure safe.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{BallMatrix{T}, BallMatrix{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:-","text":"Base.:-(A::BallMatrix, B::BallMatrix)\n\nCombine two BallMatrix values elementwise using subtraction while tracking floating-point and enclosure errors. The midpoint matrices are subtracted directly and the radii are enlarged using outward rounding to maintain a rigorous enclosure.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{BallMatrix{T}, LinearAlgebra.UniformScaling}} where T","page":"Home","title":"Base.:-","text":"-(A::BallMatrix, J::UniformScaling)\n\nSubtract a UniformScaling operator from a BallMatrix while updating the stored radii so that the result remains enclosure-safe.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{BallVector{T}, BallVector{T}}} where T<:AbstractFloat","page":"Home","title":"Base.:-","text":"Base.:-(A::BallVector, B::BallVector)\n\nCombine two ball vectors elementwise using subtraction, enlarging the radius to include roundoff and the uncertainties of both operands.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{LinearAlgebra.UniformScaling, BallMatrix{T}}} where T","page":"Home","title":"Base.:-","text":"-(J::UniformScaling, A::BallMatrix)\n\nSubtract a BallMatrix from a uniform scaling operator, useful for forming expressions such as λ * I - A with rigorous error bounds.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:/-Tuple{Ball, Ball}","page":"Home","title":"Base.:/","text":"/(x::Ball, y::Ball)\n\nDivide x by y by multiplying with the inverse of y. The operation inherits the same domain restrictions as inv.\n\n\n\n\n\n","category":"method"},{"location":"#Base.abs-Tuple{Ball}","page":"Home","title":"Base.abs","text":"abs(x::Ball)\n\nReturn a ball that encloses the absolute value of x. When the interval does not cross zero, the midpoint is simply the absolute value of the stored center; otherwise the result widens to account for the possible sign change.\n\n\n\n\n\n","category":"method"},{"location":"#Base.adjoint-Tuple{BallMatrix}","page":"Home","title":"Base.adjoint","text":"adjoint(M::BallMatrix)\n\nReturn the conjugate transpose of M, preserving rigorous enclosures by transposing both the midpoint and the radius matrices.\n\n\n\n\n\n","category":"method"},{"location":"#Base.conj-Tuple{Ball}","page":"Home","title":"Base.conj","text":"conj(x::Ball)\n\nComplex conjugate of a ball. The midpoint is conjugated while the radius remains unchanged.\n\n\n\n\n\n","category":"method"},{"location":"#Base.convert-Union{Tuple{CT}, Tuple{T}, Tuple{Type{Ball{T, CT}}, Ball}} where {T, CT}","page":"Home","title":"Base.convert","text":"Base.convert(::Type{Ball{T, CT}}, x::Ball)\n\nConvert a ball to the same enclosure expressed with alternative midpoint and radius types. This is typically used when promoting collections of balls to a common numeric representation.\n\n\n\n\n\n","category":"method"},{"location":"#Base.convert-Union{Tuple{CT}, Tuple{T}, Tuple{Type{Ball{T, CT}}, Number}} where {T, CT}","page":"Home","title":"Base.convert","text":"Base.convert(::Type{Ball{T, CT}}, c::Number)\n\nEmbed a plain number into a ball with zero radius whose midpoint matches c converted to CT.\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy-Tuple{BallArray}","page":"Home","title":"Base.copy","text":"copy(A::BallArray)\n\nCreate a fresh BallArray with copies of both midpoint and radius storage.\n\n\n\n\n\n","category":"method"},{"location":"#Base.fill-Union{Tuple{N}, Tuple{Ball, Vararg{Int64, N}}} where N","page":"Home","title":"Base.fill","text":"fill(x::Ball, dims...)\n\nCreate a BallArray where every element equals the ball x.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{BallArray, Int64}","page":"Home","title":"Base.getindex","text":"getindex(A::BallArray, inds...)\n\nIndexing a BallArray returns either a single Ball or another BallArray depending on the provided indices. Midpoints and radii are looked up independently so that the enclosure remains rigorous.\n\n\n\n\n\n","category":"method"},{"location":"#Base.imag-Union{Tuple{BallArray{T, N, T, BT, CA, RA} where {BT<:Ball{T, T}, CA<:AbstractArray{T, N}, RA<:AbstractArray{T, N}}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"Base.imag","text":"imag(A::BallArray)\n\nReturn the imaginary part of a BallArray. Real arrays produce a zero enclosure, while complex arrays keep the stored radii and extract the imaginary midpoints.\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Tuple{Number, Ball}","page":"Home","title":"Base.in","text":"in(x::Number, B::Ball)\n\nReturn true if the scalar x is contained in the ball B.\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Union{Tuple{T}, Tuple{Ball{T, Complex{T}}, Ball{T, Complex{T}}}} where T<:AbstractFloat","page":"Home","title":"Base.in","text":"in(B₁::Ball{T, Complex{T}}, B₂::Ball{T, Complex{T}})\n\nContainment test for complex balls. The check reduces the problem to the real case by comparing the distance between midpoints with the radii of the two enclosures.\n\n\n\n\n\n","category":"method"},{"location":"#Base.in-Union{Tuple{T}, Tuple{Ball{T, T}, Ball{T, T}}} where T<:AbstractFloat","page":"Home","title":"Base.in","text":"in(B₁::Ball{T}, B₂::Ball{T})\n\nCheck whether the enclosure B₁ is fully contained in B₂. The test expands the endpoints using outward rounding to ensure a rigorous decision.\n\n\n\n\n\n","category":"method"},{"location":"#Base.inv-Union{Tuple{Ball{T, Complex{T}}}, Tuple{T}} where T<:AbstractFloat","page":"Home","title":"Base.inv","text":"inv(x::Ball{T, Complex{T}})\n\nReturn the multiplicative inverse of a complex ball by using the identity x⁻¹ = conj(x) / |x|². The helper relies on the existing real-valued operations defined above to keep the enclosure rigorous.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{BallArray}","page":"Home","title":"Base.length","text":"length(A::BallArray)\n\nTotal number of elements stored in the array, matching the midpoint container.\n\n\n\n\n\n","category":"method"},{"location":"#Base.ones-Union{Tuple{N}, Tuple{B}, Tuple{Type{B}, NTuple{N, Integer}}} where {B<:Ball, N}","page":"Home","title":"Base.ones","text":"ones(::Type{Ball}, dims)\n\nReturn a BallArray whose midpoints are filled with ones and whose radii are identically zero.\n\n\n\n\n\n","category":"method"},{"location":"#Base.real-Union{Tuple{BallArray{T, N, T, BT, CA, RA} where {BT<:Ball{T, T}, CA<:AbstractArray{T, N}, RA<:AbstractArray{T, N}}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"Base.real","text":"real(A::BallArray)\n\nExtract the real part of a BallArray. For purely real storage the result is returned unchanged, while complex arrays drop the imaginary part of the midpoint.\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Tuple{BallArray, Any, Vararg{Any}}","page":"Home","title":"Base.setindex!","text":"setindex!(A::BallArray, x, inds...)\n\nAssign a value x to the given indices by storing its midpoint and radius separately.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{BallArray}","page":"Home","title":"Base.size","text":"size(A::BallArray)\n\nForward the size of the underlying midpoint storage.\n\n\n\n\n\n","category":"method"},{"location":"#Base.sqrt-Tuple{Ball{Float64, CT} where CT<:Union{Float64, ComplexF64}}","page":"Home","title":"Base.sqrt","text":"sqrt(x::Ball)\n\nPrincipal square root of a non-negative real ball. The method verifies that the enclosure stays within the domain of the square root and then propagates rounding errors to produce a rigorous result.\n\n\n\n\n\n","category":"method"},{"location":"#Base.zeros-Union{Tuple{N}, Tuple{B}, Tuple{Type{B}, NTuple{N, Integer}}} where {B<:Ball, N}","page":"Home","title":"Base.zeros","text":"zeros(::Type{Ball}, dims)\n\nAllocate a zero BallArray of the requested dimensions, using the element type's midpoint and radius types to choose the storage format.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.@down-Tuple{Any}","page":"Home","title":"BallArithmetic.@down","text":"@down expr\n\nMirror of @up that rewrites arithmetic so that each operation rounds toward -∞. The transformation is useful for computing lower bounds while sharing the same algebraic expression as the optimistic estimate.\n\n\n\n\n\n","category":"macro"},{"location":"#BallArithmetic.@up-Tuple{Any}","page":"Home","title":"BallArithmetic.@up","text":"@up expr\n\nRewrite arithmetic in expr so that every operation is evaluated with outward rounding toward +∞. The macro replaces the standard +, -, *, and / operators with the corresponding helpers from RoundingEmulator, making it convenient to derive guaranteed upper bounds for composite expressions.\n\n\n\n\n\n","category":"macro"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Certification-helpers","page":"API","title":"Certification helpers","text":"","category":"section"},{"location":"API/#BallArithmetic.CertifScripts.CertificationCircle","page":"API","title":"BallArithmetic.CertifScripts.CertificationCircle","text":"CertificationCircle(center, radius; samples = 256)\n\nDiscretisation of a circle with centre center, radius radius, and samples equally spaced points used for certification runs.\n\n\n\n\n\n","category":"type"},{"location":"API/#BallArithmetic.CertifScripts.points_on","page":"API","title":"BallArithmetic.CertifScripts.points_on","text":"points_on(circle)\n\nReturn the discretisation of circle used for certification.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.set_schur_matrix!","page":"API","title":"BallArithmetic.CertifScripts.set_schur_matrix!","text":"set_schur_matrix!(T)\n\nStore the Schur factor T used by dowork.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.configure_certification!","page":"API","title":"BallArithmetic.CertifScripts.configure_certification!","text":"configure_certification!(; job_channel, result_channel, certification_log, snapshot, io)\n\nCache common resources used by the certification helpers.  The stored values are used as defaults by adaptive_arcs! and save_snapshot!. Any keyword may be omitted to keep its previous value.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.dowork","page":"API","title":"BallArithmetic.CertifScripts.dowork","text":"dowork(jobs, results)\n\nProcess tasks received on jobs, computing the SVD certification routine for T - zI.  The Schur factor must have been registered in advance with set_schur_matrix!.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.adaptive_arcs!","page":"API","title":"BallArithmetic.CertifScripts.adaptive_arcs!","text":"adaptive_arcs!(arcs, cache, pending, η; kwargs...)\n\nDrive the adaptive refinement routine.  When job channels are provided the refinement uses asynchronous workers; otherwise the evaluation is carried out serially using the supplied evaluator.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.save_snapshot!","page":"API","title":"BallArithmetic.CertifScripts.save_snapshot!","text":"save_snapshot!(arcs, cache, log, pending, basepath, toggle)\n\nPersist the current certification state to disk using alternating files.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.choose_snapshot_to_load","page":"API","title":"BallArithmetic.CertifScripts.choose_snapshot_to_load","text":"choose_snapshot_to_load(basepath)\n\nReturn the most recent valid snapshot stored at basepath.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.compute_schur_and_error","page":"API","title":"BallArithmetic.CertifScripts.compute_schur_and_error","text":"compute_schur_and_error(A; polynomial = nothing)\n\nCompute the Schur decomposition of A and certified bounds for the orthogonality defect, the reconstruction error, and the norms of Z and Z⁻¹.  When polynomial is provided (as coefficients in ascending order), additional bounds are computed for p(A) and p(T).\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.bound_res_original","page":"API","title":"BallArithmetic.CertifScripts.bound_res_original","text":"bound_res_original(l2pseudo, η, norm_Z, norm_Z_inv, errF, errT, N)\n\nReturn an upper bound on the ℓ₁ resolvent norm of the original matrix given the bounds obtained from the Schur form.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.run_certification","page":"API","title":"BallArithmetic.CertifScripts.run_certification","text":"run_certification(A, circle; polynomial = nothing, kwargs...)\n\nRun the adaptive certification routine on circle using a serial evaluator.\n\nArguments\n\nA: matrix to certify.  Converted to BallMatrix when required.\ncircle: CertificationCircle describing the contour used for the adaptive refinement.\n\nKeyword Arguments\n\npolynomial = nothing: optional coefficients (ascending order) describing a polynomial p.  When provided the certification is carried out on p(T) and the returned error corresponds to the reconstruction error of p(A).\nη = 0.5: admissible threshold for the adaptive refinement.  Must lie in the open unit interval.\ncheck_interval = 100: number of processed arcs between progress reports and consistency checks.\nlog_io = stdout: destination IO for log messages.\nCbound = 1.0: constant used by bound_res_original when lifting resolvent bounds back to the original matrix.\n\nThe return value is a named tuple containing the computed Schur form, the accumulated certification log, and the resolvent bounds for both the Schur factor and the original matrix.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.CertifScripts.poly_from_roots","page":"API","title":"BallArithmetic.CertifScripts.poly_from_roots","text":"poly_from_roots(roots::AbstractVector)\n\nGiven a list of roots r₁, r₂, …, rₙ, returns the coefficients [a₀, a₁, …, aₙ] of the monic polynomial     p(x) = (x - r₁)(x - r₂)…(x - rₙ) so that p(x) = a₀ + a₁x + a₂x² + … + aₙ*xⁿ.\n\n\n\n\n\n","category":"function"},{"location":"API/#Sylvester-equations","page":"API","title":"Sylvester equations","text":"","category":"section"},{"location":"API/#BallArithmetic.sylvester_miyajima_enclosure","page":"API","title":"BallArithmetic.sylvester_miyajima_enclosure","text":"sylvester_miyajima_enclosure(A, B, C, X̃)\n\nCompute a Miyajima-style verified enclosure for the solution of the Sylvester problem A * X + X * B = C.  The method follows the componentwise certificate from Ref. [3] and returns a BallMatrix whose midpoint is the supplied approximation X̃ and whose radii enclose the exact solution entrywise.\n\nThe routine raises an error when the spectral gaps λ_i(A) + λ_j(B) vanish or when the contraction bound is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"API/#BallArithmetic.triangular_sylvester_miyajima_enclosure","page":"API","title":"BallArithmetic.triangular_sylvester_miyajima_enclosure","text":"triangular_sylvester_miyajima_enclosure(T, k)\n\nConstruct the Miyajima enclosure for the Sylvester system associated with the upper-triangular matrix T partitioned as\n\nT = [T₁₁  T₁₂;\n     0    T₂₂],\n\nwhere T₁₁ is k × k.  The enclosure is computed for the solution Y₂ of the transformed Sylvester equation T₂₂' * Y₂ - Y₂ * T₁₁' = T₁₂'.  Forming the standard Sylvester data A = T₂₂', B = -T₁₁', and C = T₁₂', the routine solves for an approximate Y₂ and then calls sylvester_miyajima_enclosure to obtain a verified bound.  The returned BallMatrix encloses the exact Y₂ entrywise.\n\nThe matrix T must be square and upper triangular, and the block size k must satisfy 1 ≤ k < size(T, 1).\n\n\n\n\n\n","category":"function"},{"location":"API/#Numerical-tests","page":"API","title":"Numerical tests","text":"","category":"section"},{"location":"API/#BallArithmetic.NumericalTest.rounding_test","page":"API","title":"BallArithmetic.NumericalTest.rounding_test","text":"rounding_test(n, k)\n\nLet u=fill(2^(-53), k-1) and let A be the matrix [I u; 0 2^(-53)]\n\nThis test checks the result of A*A' in different rounding modes, running BLAS on n threads\n\n\n\n\n\n","category":"function"}]
}
