var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S. M. Rump. Fast and Parallel Interval Arithmetic. BIT Numerical Mathematics 39, 534–554 (1999).\n\n\n\nN. Revol and P. Théveny. Parallel Implementation of Interval Matrix Multiplication. Reliable Computing 19, 91 (2013).\n\n\n\nS. Miyajima. Numerical enclosure for each eigenvalue in generalized eigenvalue problem. Journal of Computational and Applied Mathematics 236, 2545–2552 (2012).\n\n\n\nS. M. Rump. Verified bounds for singular values, in particular for the spectral norm of a matrix and its inverse. BIT Numerical Mathematics 51, 367–384 (2011).\n\n\n\n","category":"page"},{"location":"references/","page":"References","title":"References","text":"N. J. Higham. Accuracy and Stability of Numerical Algorithms: Second Edition (Philadelphia, PA: SIAM, 1996).\n\n\n\nS. Miyajima. Verified bounds for all the singular values of matrix. Japan Journal of Industrial and Applied Mathematics 31, 513–539 (2014).\n\n\n\nS. M. Rump and S. Oishi. A note on Oishi’s lower bound for the smallest singular value of linearized Galerkin equations. Japan Journal of Industrial and Applied Mathematics 41, 1097–1104 (2024).\n\n\n\nS. M. Rump. Verification methods: Rigorous results using floating-point arithmetic. Acta Numerica 19, 287–449 (2010).\n\n\n\n","category":"page"},{"location":"eigenvalues/","page":"Eigenvalues","title":"Eigenvalues","text":"We are interested in algorithms to compute rigorous enclosures of eigenvalues.","category":"page"},{"location":"eigenvalues/","page":"Eigenvalues","title":"Eigenvalues","text":"We implement Ref. [3]; the idea is to approach the problem  in two steps, the interested reader may refer to the treatment in Eigenvalues in Arb for a deeper discussion on the topic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BallArithmetic","category":"page"},{"location":"#BallArithmetic","page":"Home","title":"BallArithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BallArithmetic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package we use the tecniques first introduced in Ref. [1], following the more recent work Ref. [2] to implement a rigorous matrix product in mid-radius arithmetic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This allows to implement numerous algorithms developed by Rump, Miyajima, Ogita and collaborators to obtain a posteriori guaranteed bounds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main object are BallMatrices, i.e., a couple containing a center matrix and a radius matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BallArithmetic\nA = ones((2, 2))\nbA = BallMatrix(A, A/128)\nbA^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [BallArithmetic, NumericalTest]","category":"page"},{"location":"#BallArithmetic._compute_exclusion_circle_level_set_priori-Tuple{Any, Any, Any}","page":"Home","title":"BallArithmetic._compute_exclusion_circle_level_set_priori","text":"_compute_exclusion_circle_level_set_priori(T,\nλ,\nϵ;\nrel_pearl_size,\nmax_initial_newton)\n\nThis method bounds the resolvent on a circle centered at λ that intersects in at least one point z0 the ϵ level set. This intersection is found by a Newton step, and fixes the radius of the circle,\n\nThe value of rel_pearl_size gives us the relative radius of the pearls with respect to the radius of the circle\n\nSome rule of thumbs for the number of SVD computations: if relpearlsize is 1/32, we are going to compute and certify 160 svds, if relpearlsize is 1/64 we are going to compute and certify 320 svds. In other words, the time of the computation scales linearly with the quality of the pearl necklace\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.collatz_upper_bound_L2_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.collatz_upper_bound_L2_opnorm","text":"collatz_upper_bound_L2_opnorm(A::BallMatrix; iterates=10)\n\nGive a rigorous upper bound on the ℓ² norm of the matrix A by using the Collatz theorem.\n\nWe use Perron theory here: if for two matrices with B positive |A| < B we have ρ(A)<=ρ(B) by Wielandt's theorem Wielandt's theorem\n\nThe keyword argument iterates is used to establish how many times we are iterating the vector of ones before we use Collatz's estimate.\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.compute_enclosure-Tuple{BallMatrix, Any, Any, Any}","page":"Home","title":"BallArithmetic.compute_enclosure","text":"compute_enclosure(A::BallMatrix, r1, r2, ϵ; max_initial_newton = 30,\n        max_steps = Int64(ceil(256 * π)), rel_steps = 16)\n\nGiven a BallMatrix `A`, this method follows the level lines of level `ϵ`\n\naround the eigenvalues with modulus bound between r1 and r2.\n\nThe keyword arguments     - maxinitialnewton: maximum number of newton steps to reach the level lines     - maxsteps: maximum number of steps following the contour     - relsteps: relative integration step for the Euler method\n\nThe method outputs an array of truples:     - the first element is the eigenvalue we are enclosing     (in the case of the excluding circles, it is 0.0 or the maximum modulus of the eigenvalues)     - the second element is an upper bound on the resolvent norm     - the third element is a list of points on the enclosing line; the resolvent is rigorously     bound on circles centered at each point and of radius 5/8 the distance to the previous point\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.diagonal_abs_lower_bound-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.diagonal_abs_lower_bound","text":"Computes a vector containing lower bounds for the diagonal elements of |A|\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.epsilon_inflation-Union{Tuple{T}, Tuple{BallMatrix{T}, BallVector{T}}} where T<:AbstractFloat","page":"Home","title":"BallArithmetic.epsilon_inflation","text":"epsilon_inflation(A::BallMatrix{T}, b::BallVector{T};\n                  r=0.1, ϵ=1e-20, iter_max=20) where {T<:AbstractFloat}\n\nGives an enclosure of the solution of the square linear system Ax=b using the ϵ-inflation algorithm,  see algorithm 10.7 of\n\nInput\n\nA        – square matrix of size n × n\nb        – vector of length n or matrix of size n × m\nr        – relative inflation, default 10%\nϵ        – absolute inflation, default 1e-20\niter_max – maximum number of iterations\n\nOutput\n\nx    – enclosure of the solution of the linear system\ncert – Boolean flag, if cert==true, then x is certified to contain the true\n\nsolution of the linear system, if cert==false, then the algorithm could not prove that x actually contains the true solution.\n\nAlgorithm\n\nGiven the real system Ax=b and an approximate solution x, we initialize x₀ = x x. At each iteration the algorithm computes the inflation\n\ny = xₖ * 1 - r 1 + r + -ϵ ϵ\n\nand the update\n\nxₖ₁ = Z + (I - CA)y,\n\nwhere Z = C(b - Ax₀) and C is an approximate inverse of A. If the condition xₖ₁  y is met, then xₖ₁ is a proved enclosure of A¹b and cert is set to true. If the condition is not met by the maximum number of iterations, the latest computed enclosure is returned, but cert is set to false, meaning the algorithm could not prove that the enclosure contains the true solution. For interval systems, x is obtained considering the midpoint of A and b.\n\nNotes\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.evbox-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.evbox","text":"evbox(A::BallMatrix{T})\n\nCompute rigorous enclosure of each eigenvalue following Ref. [3] TODO: Using Miyajima's algorithm is overkill, may be worth using\n\nReferences\n\n[3] Miyajima, JCAM 246, 9 (2012)\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.gevbox-Union{Tuple{T}, Tuple{BallMatrix{T}, BallMatrix{T}}} where T","page":"Home","title":"BallArithmetic.gevbox","text":"gevbox(A::BallMatrix{T}, B::BallMatrix{T})\n\nCompute rigorous enclosure of each eigenvalue in generalized eigenvalue problem following Ref. [3]\n\nReferences\n\n[3] Miyajima, JCAM 246, 9 (2012)\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.is_M_matrix-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.is_M_matrix","text":"Rigorous computer assisted proof of the fact that a matrix is an M-matrix\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.off_diagonal_abs-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.off_diagonal_abs","text":"Returns a matrix containing the off-diagonal elements\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svd_bound_L2_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.svd_bound_L2_opnorm","text":"svd_bound_L2_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ²-norm of the ball matrix A using the rigorous enclosure for the singular values implemented in svd/svd.jl\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svd_bound_L2_opnorm_inverse-Tuple{BallMatrix}","page":"Home","title":"BallArithmetic.svd_bound_L2_opnorm_inverse","text":"svd_bound_L2_opnorm_inverse(A::BallMatrix)\n\nReturns a rigorous upper bound on the ℓ²-norm of the inverse of the ball matrix A using the rigorous enclosure for the singular values implemented in svd/svd.jl\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svd_bound_L2_resolvent-Tuple{BallMatrix, Ball}","page":"Home","title":"BallArithmetic.svd_bound_L2_resolvent","text":"svd_bound_L2_resolvent(A::BallMatrix, lam::Ball)\n\nReturns a rigorous upper bound on the ℓ²-norm of the resolvent of A at λ, i.e., ||(A-λ)^{-1}||_{ℓ²}\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.svdbox-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.svdbox","text":"svdbox\n\nThis follows Theorem 3.1 in Ref. [4]\n\nReferences\n\n[4] Rump S., BIT 51, 2 (2011)\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_abs-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_abs","text":"upper_abs(A)\n\nReturn a floating point matrix B whose entries are bigger or equal (componentwise) any of the entries of A\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_L1_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_bound_L1_opnorm","text":"upper_bound_L1_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ¹-norm of the ball matrix A\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_L2_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_bound_L2_opnorm","text":"upper_bound_L_inf_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ²-norm of the ball matrix A using the best between the Collatz bound and the interpolation bound\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_L_inf_opnorm-Union{Tuple{BallMatrix{T}}, Tuple{T}} where T","page":"Home","title":"BallArithmetic.upper_bound_L_inf_opnorm","text":"upper_bound_L_inf_opnorm(A::BallMatrix{T})\n\nReturns a rigorous upper bound on the ℓ-∞-norm of the ball matrix A\n\n\n\n\n\n","category":"method"},{"location":"#BallArithmetic.upper_bound_norm","page":"Home","title":"BallArithmetic.upper_bound_norm","text":"upper_bound_norm(v::BallVector, p::Real = 2)\n\nCompute a rigorous upper bound for the p-norm of a BallVector\n\n\n\n\n\n","category":"function"},{"location":"#BallArithmetic.upper_bound_norm-2","page":"Home","title":"BallArithmetic.upper_bound_norm","text":"upper_bound_norm(A::BallMatrix, p::Real = 2)\n\nCompute a rigorous upper bound for the Frobenius p-norm of a BallMatrix\n\n\n\n\n\n","category":"function"},{"location":"#BallArithmetic.NumericalTest.rounding_test-Tuple{Any, Any}","page":"Home","title":"BallArithmetic.NumericalTest.rounding_test","text":"rounding_test(n, k)\n\nLet u=fill(2^(-53), k-1) and let A be the matrix [I u; 0 2^(-53)]\n\nThis test checks the result of A*A' in different rounding modes, running BLAS on n threads\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"","category":"page"}]
}
