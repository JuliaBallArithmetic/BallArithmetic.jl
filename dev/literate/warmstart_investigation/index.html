<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Warm-Start Investigation for Circle Certification · BallArithmetic.jl</title><meta name="title" content="Warm-Start Investigation for Circle Certification · BallArithmetic.jl"/><meta property="og:title" content="Warm-Start Investigation for Circle Certification · BallArithmetic.jl"/><meta property="twitter:title" content="Warm-Start Investigation for Circle Certification · BallArithmetic.jl"/><meta name="description" content="Documentation for BallArithmetic.jl."/><meta property="og:description" content="Documentation for BallArithmetic.jl."/><meta property="twitter:description" content="Documentation for BallArithmetic.jl."/><meta property="og:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/literate/warmstart_investigation/"/><meta property="twitter:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/literate/warmstart_investigation/"/><link rel="canonical" href="https://juliaballarithmetic.github.io/BallArithmetic.jl/literate/warmstart_investigation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BallArithmetic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../decompositions/">Matrix Decompositions</a></li><li><a class="tocitem" href="../../svd/">SVD</a></li><li><a class="tocitem" href="../../eigenvalues/">Eigenvalues</a></li><li><a class="tocitem" href="../../pseudospectra/">Pseudospectra</a></li><li><a class="tocitem" href="../../linearsystems/">Linear Systems</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/">Overview</a></li><li><a class="tocitem" href="../../api/core/">Core Types</a></li><li><a class="tocitem" href="../../api/linearsystems/">Linear Systems</a></li><li><a class="tocitem" href="../../api/eigenvalues/">Eigenvalues &amp; SVD</a></li><li><a class="tocitem" href="../../api/certifscripts/">CertifScripts</a></li><li><a class="tocitem" href="../../api/numericaltest/">NumericalTest</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Warm-Start Investigation for Circle Certification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Warm-Start Investigation for Circle Certification</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/main/docs/src/literate/warmstart_investigation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Warm-Start-Investigation-for-Circle-Certification"><a class="docs-heading-anchor" href="#Warm-Start-Investigation-for-Circle-Certification">Warm-Start Investigation for Circle Certification</a><a id="Warm-Start-Investigation-for-Circle-Certification-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Start-Investigation-for-Circle-Certification" title="Permalink"></a></h1><h2 id="Executive-Summary"><a class="docs-heading-anchor" href="#Executive-Summary">Executive Summary</a><a id="Executive-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Executive-Summary" title="Permalink"></a></h2><p><strong>Goal:</strong> Accelerate resolvent certification at multiple points around a circle.</p><p><strong>Key findings:</strong></p><ol><li>Direct warm-start of Ogita refinement <strong>fails</strong> - fresh Float64 SVD is more accurate than reusing previous point&#39;s SVD</li><li>Warm-start of the Float64 SVD computation provides <strong>modest speedup (1.1-1.2x)</strong></li><li>All extended precision methods (Double64, BigFloat) give <strong>identical certified bounds</strong></li><li><strong>Double64 is 10-20x faster than BigFloat</strong> for the refinement phase</li><li><strong>Sub-machine-precision circles work</strong> - BigFloat center + Ogita refinement can certify circles with radius ≤ 1e-16</li></ol><p><strong>Recommended algorithm (normal radius r &gt; 1e-14):</strong></p><ol><li>Compute Float64 SVD (cold or warm-started via power iteration)</li><li>Refine with Double64 (~106 bits) for 2 iterations</li><li>Final certification with BigFloat (256+ bits)</li></ol><p><strong>Algorithm for sub-ε radius (r ≤ 1e-16):</strong></p><ol><li>Represent center and radius in BigFloat (256+ bits)</li><li>Compute Float64 SVD at center (same for all points)</li><li>For each point: Ogita refinement in BigFloat starting from center&#39;s SVD</li><li>Distinct σ_min values achieved despite identical Float64 representations</li></ol><p><strong>Precision cascade investigation:</strong></p><p>We tested adaptive cascades: Float64 → Double64 → Float64x3 → Float64x4 → BigFloat.</p><p><strong>Findings:</strong></p><ul><li>LAPACK&#39;s Float64 SVD is already near-optimal (residual ~1e-14)</li><li>First Ogita iteration at Float64 can <em>increase</em> residual (rounding effects)</li><li>Pure BigFloat (5 iterations) achieves ~1e-76 residual via quadratic convergence</li><li>Cascade achieves ~1e-14 residual in similar time - no speedup for small matrices</li></ul><p><strong>GenericLinearAlgebra discovery:</strong></p><p>GenericLinearAlgebra.jl provides a native BigFloat SVD that is both <strong>faster and more accurate</strong> than all cascade methods. It computes SVD directly at full precision without needing refinement.</p><p><strong>Final benchmark (100×100 matrix, 256-bit BigFloat):</strong></p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Time</th><th style="text-align: right">Residual</th><th style="text-align: right">Speedup</th></tr><tr><td style="text-align: right"><strong>GLA (no refine)</strong></td><td style="text-align: right"><strong>4.2s</strong></td><td style="text-align: right"><strong>4e-74</strong></td><td style="text-align: right"><strong>6.6x</strong></td></tr><tr><td style="text-align: right">D64 only: F64→D64→BF</td><td style="text-align: right">11.7s</td><td style="text-align: right">1e-12</td><td style="text-align: right">2.4x</td></tr><tr><td style="text-align: right">Minimal: F64→MF3→BF</td><td style="text-align: right">12.2s</td><td style="text-align: right">1e-12</td><td style="text-align: right">2.3x</td></tr><tr><td style="text-align: right">Full cascade</td><td style="text-align: right">15.0s</td><td style="text-align: right">1e-13</td><td style="text-align: right">1.8x</td></tr><tr><td style="text-align: right">Pure Ogita: F64→BF(5)</td><td style="text-align: right">27.7s</td><td style="text-align: right">1e-12</td><td style="text-align: right">1.0x</td></tr></table><p><strong>Key insights:</strong></p><ul><li>GLA is 6.6x faster than pure Ogita and 2.8x faster than the best cascade</li><li>GLA achieves 60+ orders of magnitude better residual (1e-74 vs 1e-12)</li><li>Refinement iterations are unnecessary for GLA (and slightly degrade accuracy)</li><li>Simpler cascades (D64 only) outperform complex ones (full cascade)</li></ul><p><strong>Timing comparison (n=200 matrix, single point):</strong> | Method | Time | Residual | Speedup | |––––|–––|–––––|––––-| | Cascade (1×F64→1×D64→1×MF3→1×MF4→2×BF) | 196s | 3.3e-12 | <strong>2.08x</strong> | | Pure BigFloat (5 iter) | 407s | 5.0e-12 | 1.0x |</p><p><strong>Timing comparison (n=500 matrix, single point):</strong> | Method | Time | Residual | Speedup | |––––|–––|–––––|––––-| | Cascade (1×F64→1×D64→1×MF3→1×MF4→2×BF) | 3234s | 1.4e-11 | <strong>1.94x</strong> | | Pure BigFloat (5 iter) | 6279s | 1.6e-11 | 1.0x |</p><p><strong>Recommended methods:</strong></p><pre><code class="language-julia hljs"># Best overall (requires GenericLinearAlgebra):
using BallArithmetic, GenericLinearAlgebra
result = ogita_svd_cascade_gla(T_bf, z_bf)  # 6.6x faster, 1e-74 residual

# Without GenericLinearAlgebra (use simplest cascade):
using BallArithmetic, MultiFloats
result = ogita_svd_cascade(T_bf, z_bf;
    f64_iters=1, d64_iters=1, mf3_iters=0, mf4_iters=0, bf_iters=2)</code></pre><p><strong>Conclusion:</strong></p><ul><li><strong>Use GLA</strong> (<code>ogita_svd_cascade_gla</code>) when possible - fastest and most accurate</li><li>For matrices without GLA, use <strong>D64 only cascade</strong> (F64→D64→BF)</li><li>The full cascade with MF3/MF4 adds overhead without significant benefit</li></ul><h2 id="Terminology"><a class="docs-heading-anchor" href="#Terminology">Terminology</a><a id="Terminology-1"></a><a class="docs-heading-anchor-permalink" href="#Terminology" title="Permalink"></a></h2><ul><li><strong>Cold-start SVD</strong>: Compute full SVD from scratch using LAPACK (<code>svd(A)</code>)</li><li><strong>Warm-start SVD</strong>: Use previous point&#39;s U, V as initial guess, refine via power/subspace iteration</li><li><strong>Ogita refinement</strong>: Iterative algorithm that refines an approximate SVD to high precision (quadratic convergence)</li><li><strong>Double64</strong>: Extended precision type (~106 bits) from DoubleFloats.jl - used in <code>ogita_svd_refine_fast</code></li><li><strong>BigFloat</strong>: Arbitrary precision floating point - used for final rigorous certification</li><li><strong>Miyajima method</strong>: Ball arithmetic SVD certification (rigorous but slower)</li></ul><h2 id="Problem-Setup"><a class="docs-heading-anchor" href="#Problem-Setup">Problem Setup</a><a id="Problem-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Setup" title="Permalink"></a></h2><p>When certifying the resolvent norm <code>||(zI - A)^{-1}||</code> at multiple points <code>z</code> around a circle, adjacent points have similar shifted matrices:</p><ul><li><code>A - z₁I</code> and <code>A - z₂I</code> differ only by <code>(z₂ - z₁)I</code></li><li>For a circle with <code>n</code> points, adjacent distance is <code>|Δz| ≈ 2πr/n</code></li></ul><p><strong>Question:</strong> Can we use the SVD from point <code>z₁</code> to accelerate certification at <code>z₂</code>?</p><h2 id="Key-Findings"><a class="docs-heading-anchor" href="#Key-Findings">Key Findings</a><a id="Key-Findings-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Findings" title="Permalink"></a></h2><h3 id="1.-Singular-Vector-Rotation"><a class="docs-heading-anchor" href="#1.-Singular-Vector-Rotation">1. Singular Vector Rotation</a><a id="1.-Singular-Vector-Rotation-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Singular-Vector-Rotation" title="Permalink"></a></h3><p>Even for small <code>|Δz|</code>, singular vectors can rotate significantly:</p><p>| |Δz| | Min Overlap | Warm-Start | |–––|––––––-|––––––| | 0.115 | 0.79 | Fails | | 0.058 | 0.94 | Works | | 0.029 | 0.99 | Works | | 0.015 | 0.996 | Works |</p><p><strong>Threshold:</strong> Warm-start works when <code>min_overlap &gt; 0.94</code>, requiring <code>|Δz| &lt; 0.06</code>.</p><h3 id="2.-Singular-Value-Crossings"><a class="docs-heading-anchor" href="#2.-Singular-Value-Crossings">2. Singular Value Crossings</a><a id="2.-Singular-Value-Crossings-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Singular-Value-Crossings" title="Permalink"></a></h3><p>The singular vectors rotate because singular values reorder as <code>z</code> changes:</p><ul><li>At different <code>z</code>, the minimum gap moves between different singular value pairs</li><li>This causes the corresponding singular vectors to &quot;exchange roles&quot;</li><li>Even without coalescence, vectors rotate within near-degenerate subspaces</li></ul><p>Example from our test matrix:</p><pre><code class="nohighlight hljs">θ=0.0:  min gap at σ[14]-σ[15]
θ=0.79: min gap at σ[29]-σ[30]
θ=1.18: min gap at σ[29]-σ[30]</code></pre><h3 id="3.-Ogita-Refinement-Requires-Accurate-Initial-Guess"><a class="docs-heading-anchor" href="#3.-Ogita-Refinement-Requires-Accurate-Initial-Guess">3. Ogita Refinement Requires Accurate Initial Guess</a><a id="3.-Ogita-Refinement-Requires-Accurate-Initial-Guess-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Ogita-Refinement-Requires-Accurate-Initial-Guess" title="Permalink"></a></h3><p>Comparing cold-start (fresh SVD) vs warm-start (previous point&#39;s SVD):</p><table><tr><th style="text-align: right">Iter</th><th style="text-align: right">Cold Residual</th><th style="text-align: right">Warm Residual</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">2e-26</td><td style="text-align: right">1.3e-04</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">1e-43</td><td style="text-align: right">5.6e-07</td></tr><tr><td style="text-align: right">3</td><td style="text-align: right">2e-57</td><td style="text-align: right">3e-08</td></tr><tr><td style="text-align: right">5</td><td style="text-align: right">4e-85</td><td style="text-align: right">9e-11</td></tr></table><p><strong>Key insight:</strong> Fresh Float64 SVD has O(ε_machine) ≈ 1e-16 error, while warm-start from adjacent point has O(|Δz|) ≈ 1e-3 error. Cold-start wins!</p><h3 id="4.-Why-Warm-Start-Fails-for-Ogita-Refinement"><a class="docs-heading-anchor" href="#4.-Why-Warm-Start-Fails-for-Ogita-Refinement">4. Why Warm-Start Fails for Ogita Refinement</a><a id="4.-Why-Warm-Start-Fails-for-Ogita-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Why-Warm-Start-Fails-for-Ogita-Refinement" title="Permalink"></a></h3><p>Ogita&#39;s RefSVD algorithm assumes the initial SVD approximation has error O(ε_machine). With quadratic convergence:</p><ul><li>From 1e-16 error: 2 iterations reach 1e-32, 3 iterations reach 1e-64</li><li>From 1e-3 error: 2 iterations reach 1e-6, 5 iterations reach 1e-48</li></ul><p>The O(|Δz|) error from warm-start is too large for efficient refinement.</p><h3 id="5.-Near-Eigenvalue-Certification-Needs-BigFloat"><a class="docs-heading-anchor" href="#5.-Near-Eigenvalue-Certification-Needs-BigFloat">5. Near-Eigenvalue Certification Needs BigFloat</a><a id="5.-Near-Eigenvalue-Certification-Needs-BigFloat-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Near-Eigenvalue-Certification-Needs-BigFloat" title="Permalink"></a></h3><p>Testing with decreasing radius around center λ = 1.0:</p><table><tr><th style="text-align: right">Radius</th><th style="text-align: right">σ_min</th><th style="text-align: right">Status</th></tr><tr><td style="text-align: right">0.050</td><td style="text-align: right">3.4e-03</td><td style="text-align: right">Float64 OK</td></tr><tr><td style="text-align: right">0.030</td><td style="text-align: right">5.4e-04</td><td style="text-align: right">Float64 OK</td></tr><tr><td style="text-align: right">0.022</td><td style="text-align: right">7.9e-05</td><td style="text-align: right">Float64 OK</td></tr><tr><td style="text-align: right">0.020</td><td style="text-align: right">0</td><td style="text-align: right">SINGULAR (on eigenvalue)</td></tr><tr><td style="text-align: right">0.018</td><td style="text-align: right">7.2e-05</td><td style="text-align: right">Float64 OK</td></tr><tr><td style="text-align: right">0.005</td><td style="text-align: right">2.6e-04</td><td style="text-align: right">Float64 OK</td></tr></table><p>At radius = 0.02, the circle passes exactly through an eigenvalue. BigFloat is essential for certifying near eigenvalues where σ_min is tiny.</p><h2 id="Precision-Comparison-(Cold-Start)"><a class="docs-heading-anchor" href="#Precision-Comparison-(Cold-Start)">Precision Comparison (Cold-Start)</a><a id="Precision-Comparison-(Cold-Start)-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-Comparison-(Cold-Start)" title="Permalink"></a></h2><p>All methods give identical certified bounds when they succeed:</p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Time (8 pts)</th><th style="text-align: right">Accuracy</th></tr><tr><td style="text-align: right">Double64</td><td style="text-align: right">0.32s</td><td style="text-align: right">1.00x</td></tr><tr><td style="text-align: right">BigFloat</td><td style="text-align: right">3.21s</td><td style="text-align: right">1.00x</td></tr><tr><td style="text-align: right">MultiFloat</td><td style="text-align: right">1.46s</td><td style="text-align: right">1.00x</td></tr><tr><td style="text-align: right">Float64 (Miyajima)</td><td style="text-align: right">6.86s</td><td style="text-align: right">1.00x</td></tr></table><p><strong>Recommendation:</strong> Use Double64 for best speed/accuracy tradeoff.</p><h2 id="Warm-Start-Float64-SVD:-Implementation-and-Results"><a class="docs-heading-anchor" href="#Warm-Start-Float64-SVD:-Implementation-and-Results">Warm-Start Float64 SVD: Implementation and Results</a><a id="Warm-Start-Float64-SVD:-Implementation-and-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Start-Float64-SVD:-Implementation-and-Results" title="Permalink"></a></h2><p>Since Ogita refinement benefits from accurate Float64 SVD, we implemented warm-starting the SVD computation itself using subspace iteration.</p><h3 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h3><pre><code class="language-julia hljs">function warm_svd(A, U_init, V_init; max_iter=2)
    V = copy(V_init)
    for iter in 1:max_iter
        U = A * V;  U, _ = qr(U)  # Power iteration
        V = A&#39; * U; V, _ = qr(V)
    end
    U = A * V; U, _ = qr(U)
    S = diag(U&#39; * A * V)
    return U, S, V
end</code></pre><h3 id="Quality-of-Warm-SVD-Approximation"><a class="docs-heading-anchor" href="#Quality-of-Warm-SVD-Approximation">Quality of Warm SVD Approximation</a><a id="Quality-of-Warm-SVD-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Quality-of-Warm-SVD-Approximation" title="Permalink"></a></h3><p>| Power Iter | Residual ||A - USV&#39;|| | σ_min error | |––––––|––––––––––––|––––––-| | 0 (direct) | 9.8e-04 | 4.2e-02 | | 1 | 5.67 | 8.6e-13 | | 2 | 5.67 | 4.2e-13 | | Cold SVD | 1.4e-14 | 0 |</p><p>The large residual after power iteration is due to subspace basis differences, but singular VALUES are accurate (σ_min error ~1e-13).</p><h3 id="Full-Chain-Results-(32-points,-radius0.005)"><a class="docs-heading-anchor" href="#Full-Chain-Results-(32-points,-radius0.005)">Full Chain Results (32 points, radius=0.005)</a><a id="Full-Chain-Results-(32-points,-radius0.005)-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Chain-Results-(32-points,-radius0.005)" title="Permalink"></a></h3><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Time</th><th style="text-align: right">Success</th><th style="text-align: right">Bound Agreement</th></tr><tr><td style="text-align: right">Cold SVD + Ogita</td><td style="text-align: right">13.11s</td><td style="text-align: right">32/32</td><td style="text-align: right">reference</td></tr><tr><td style="text-align: right">Warm SVD + Ogita</td><td style="text-align: right">13.38s</td><td style="text-align: right">32/32</td><td style="text-align: right">mean 5.6e-12</td></tr><tr><td style="text-align: right"><strong>Speedup</strong></td><td style="text-align: right"><strong>0.98x</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><h3 id="Speedup-vs-Matrix-Size"><a class="docs-heading-anchor" href="#Speedup-vs-Matrix-Size">Speedup vs Matrix Size</a><a id="Speedup-vs-Matrix-Size-1"></a><a class="docs-heading-anchor-permalink" href="#Speedup-vs-Matrix-Size" title="Permalink"></a></h3><p>Testing warm SVD speedup at different matrix sizes:</p><table><tr><th style="text-align: right">n</th><th style="text-align: right">Cold Time</th><th style="text-align: right">Warm Time</th><th style="text-align: right">Speedup</th></tr><tr><td style="text-align: right">30</td><td style="text-align: right">9.84s</td><td style="text-align: right">8.24s</td><td style="text-align: right"><strong>1.20x</strong></td></tr><tr><td style="text-align: right">50</td><td style="text-align: right">29.97s</td><td style="text-align: right">29.48s</td><td style="text-align: right">1.02x</td></tr><tr><td style="text-align: right">100</td><td style="text-align: right">300.89s</td><td style="text-align: right">279.36s</td><td style="text-align: right"><strong>1.08x</strong></td></tr></table><p><strong>Conclusion:</strong> Warm SVD provides modest speedup (1.08-1.20x) that varies with matrix size. The benefit is real but limited because:</p><ul><li>Power iterations cost O(n²) per iteration vs O(n³) for full SVD</li><li>With 2 power iterations, cost is ~O(n²) vs O(n³) - should help more for larger n</li><li>But BigFloat refinement cost (O(n³)) dominates the overall time</li></ul><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><table><tr><th style="text-align: right">Approach</th><th style="text-align: right">Works?</th><th style="text-align: right">Speedup</th><th style="text-align: right">Notes</th></tr><tr><td style="text-align: right">Warm Ogita (from prev z)</td><td style="text-align: right">No</td><td style="text-align: right">-</td><td style="text-align: right">Initial error O(</td></tr><tr><td style="text-align: right">Warm Ogita (small</td><td style="text-align: right">Δz</td><td style="text-align: right">)</td><td style="text-align: right">Yes</td></tr><tr><td style="text-align: right">Warm Float64 SVD</td><td style="text-align: right">Yes</td><td style="text-align: right"><strong>1.08-1.20x</strong></td><td style="text-align: right">Modest speedup, varies with n</td></tr></table><p><strong>Best approach:</strong> Use Double64 cold-start (10-20x faster than BigFloat). Warm SVD provides additional 1.1-1.2x speedup on top of that.</p><h2 id="Implementation-Notes"><a class="docs-heading-anchor" href="#Implementation-Notes">Implementation Notes</a><a id="Implementation-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Notes" title="Permalink"></a></h2><p>The benchmark code is in <code>docs/src/literate/benchmark_warmstart_circle.jl</code>.</p><p>Key functions:</p><ul><li><code>certify_circle_cold()</code> - BigFloat refinement, fresh SVD each point</li><li><code>certify_circle_cold_d64()</code> - Double64 refinement</li><li><code>certify_circle_cold_mf()</code> - MultiFloat refinement</li><li><code>certify_circle_float64()</code> - Miyajima (ball arithmetic) certification</li></ul><h2 id="Floating-Point-Boundary-Case-(radius-ε_machine)"><a class="docs-heading-anchor" href="#Floating-Point-Boundary-Case-(radius-ε_machine)">Floating-Point Boundary Case (radius ≤ ε_machine)</a><a id="Floating-Point-Boundary-Case-(radius-ε_machine)-1"></a><a class="docs-heading-anchor-permalink" href="#Floating-Point-Boundary-Case-(radius-ε_machine)" title="Permalink"></a></h2><h3 id="The-Problem"><a class="docs-heading-anchor" href="#The-Problem">The Problem</a><a id="The-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Problem" title="Permalink"></a></h3><p>When the circle radius is at or below machine precision (r ≤ 1e-16):</p><ul><li>All points <code>z = center + r·e^{iθ}</code> round to the <strong>same Float64 value</strong> as the center</li><li>Float64 SVD gives the <strong>same result for all points</strong></li><li>We lose the ability to distinguish points on the circle</li></ul><h3 id="Proposed-Solution:-BigFloat-Center"><a class="docs-heading-anchor" href="#Proposed-Solution:-BigFloat-Center">Proposed Solution: BigFloat Center</a><a id="Proposed-Solution:-BigFloat-Center-1"></a><a class="docs-heading-anchor-permalink" href="#Proposed-Solution:-BigFloat-Center" title="Permalink"></a></h3><p>If the center is represented in BigFloat with sufficient precision:</p><pre><code class="language-julia hljs">center_bf = BigFloat(&quot;1.0&quot;)  # Exact
radius = BigFloat(&quot;1e-20&quot;)   # Sub-machine-precision radius
z_bf = center_bf + radius * exp(im * θ)  # Distinct in BigFloat</code></pre><p><strong>Algorithm for sub-ε circles:</strong></p><ol><li>Represent center and radius in BigFloat</li><li>Compute <code>A - z*I</code> in BigFloat precision</li><li>For initial SVD approximation:<ul><li>Option A: Compute SVD at nearest Float64 point, then refine</li><li>Option B: Use BigFloat SVD directly (slower but more robust)</li></ul></li><li>Apply Ogita refinement in BigFloat</li><li>Certify with ball arithmetic</li></ol><h3 id="Key-Insight"><a class="docs-heading-anchor" href="#Key-Insight">Key Insight</a><a id="Key-Insight-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Insight" title="Permalink"></a></h3><p>At Float64 boundary, the initial SVD approximation comes from the <strong>center point</strong>:</p><ul><li><code>A - z_bf*I ≈ A - center*I</code> in Float64</li><li>The Float64 SVD of <code>A - center*I</code> serves as initial guess for ALL points</li><li>Ogita refinement corrects the O(r) perturbation</li></ul><p>This is similar to warm-start but <strong>forced by precision limits</strong> - all points share the same Float64 approximation, refined individually in BigFloat.</p><h3 id="Experimental-Verification"><a class="docs-heading-anchor" href="#Experimental-Verification">Experimental Verification</a><a id="Experimental-Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-Verification" title="Permalink"></a></h3><p>We tested certification at radius = 1e-16 (machine precision) near the eigenvalue cluster.</p><p><strong>Test setup:</strong></p><ul><li>Center: z = 1.02 (just outside eigenvalue cluster at 1.0 ± 0.02)</li><li>Radius: 1e-16 (machine precision)</li><li>8 points on the circle</li><li>Float64 SVD at center gives σ_min ≈ 2.9e-16 (essentially meaningless)</li></ul><p><strong>Results:</strong> BigFloat Ogita refinement successfully distinguishes all 8 points:</p><table><tr><th style="text-align: right">Point</th><th style="text-align: right">σ_min (BigFloat)</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">3.089e-18</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">3.318e-18</td></tr><tr><td style="text-align: right">3</td><td style="text-align: right">3.815e-18</td></tr><tr><td style="text-align: right">4</td><td style="text-align: right">4.254e-18</td></tr><tr><td style="text-align: right">5</td><td style="text-align: right">4.424e-18</td></tr><tr><td style="text-align: right">6</td><td style="text-align: right">4.254e-18</td></tr><tr><td style="text-align: right">7</td><td style="text-align: right">3.815e-18</td></tr><tr><td style="text-align: right">8</td><td style="text-align: right">3.318e-18</td></tr></table><p><strong>Key metrics:</strong></p><ul><li>σ_min variation: 1.33e-18 (Max - Min)</li><li>Relative variation: <strong>43%</strong> across the circle</li><li>Residuals: ~1e-75 (converged to full BigFloat precision)</li></ul><h3 id="Sub-Machine-Precision-Differences"><a class="docs-heading-anchor" href="#Sub-Machine-Precision-Differences">Sub-Machine-Precision Differences</a><a id="Sub-Machine-Precision-Differences-1"></a><a class="docs-heading-anchor-permalink" href="#Sub-Machine-Precision-Differences" title="Permalink"></a></h3><p>Testing whether Ogita can distinguish points that differ by 1e-20:</p><pre><code class="nohighlight hljs">z1 = 1.02 + 0i
z2 = 1.02 + 1e-20 + 0i
Same Float64? YES (both round to 1.02)</code></pre><p><strong>Results:</strong></p><ul><li>z1: σ_min = 6.6725e-19</li><li>z2: σ_min = 6.6688e-19</li><li>Difference: 0.06% (distinguishable!)</li></ul><h3 id="Precision-Requirements"><a class="docs-heading-anchor" href="#Precision-Requirements">Precision Requirements</a><a id="Precision-Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Precision-Requirements" title="Permalink"></a></h3><p>Testing what BigFloat precision is needed to resolve 1e-18 differences:</p><p>| Precision | max|A₁ - A₂| | |–––––-|––––––––| | 64 bits | 9.76e-19 | | 128 bits | 1.00e-18 | | 256 bits | 1.00e-18 | | 512 bits | 1.00e-18 |</p><p><strong>Conclusion:</strong> 64 bits (~19 decimal digits) is sufficient to represent 1e-18 differences. Standard 256-bit BigFloat provides ample headroom.</p><h3 id="Float64-Collapse-Threshold"><a class="docs-heading-anchor" href="#Float64-Collapse-Threshold">Float64 Collapse Threshold</a><a id="Float64-Collapse-Threshold-1"></a><a class="docs-heading-anchor-permalink" href="#Float64-Collapse-Threshold" title="Permalink"></a></h3><p>Testing when Float64 representations become identical (pure real points):</p><table><tr><th style="text-align: right">Radius</th><th style="text-align: right">Distinct Float64 values</th></tr><tr><td style="text-align: right">1e-14</td><td style="text-align: right">5/8</td></tr><tr><td style="text-align: right">1e-15</td><td style="text-align: right">5/8</td></tr><tr><td style="text-align: right">1e-16</td><td style="text-align: right">1/8</td></tr><tr><td style="text-align: right">1e-17</td><td style="text-align: right">1/8</td></tr><tr><td style="text-align: right">1e-18</td><td style="text-align: right">1/8</td></tr></table><p>At radius ≤ 1e-16, all real-axis points collapse to the same Float64 value. Complex points may remain distinct due to imaginary part encoding.</p><h3 id="Validated-Algorithm"><a class="docs-heading-anchor" href="#Validated-Algorithm">Validated Algorithm</a><a id="Validated-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Validated-Algorithm" title="Permalink"></a></h3><p>For sub-ε circles, the following algorithm is <strong>proven to work</strong>:</p><pre><code class="language-julia hljs"># 1. Setup in BigFloat
setprecision(BigFloat, 256)
center_bf = Complex{BigFloat}(BigFloat(&quot;1.02&quot;), BigFloat(&quot;0.0&quot;))
radius_bf = BigFloat(&quot;1e-16&quot;)

# 2. Generate points in BigFloat
θs = [BigFloat(2π * k / n) for k in 0:n-1]
zs_bf = [center_bf + radius_bf * exp(im * θ) for θ in θs]

# 3. Get initial SVD from center (Float64)
A_center = Complex{Float64}.(T) - Float64.(center_bf) * I
U_init, S_init, V_init = svd(A_center)

# 4. Certify each point with BigFloat Ogita
for z in zs_bf
    A_bf = T_bf - z * I
    U_bf = convert.(Complex{BigFloat}, U_init)
    S_bf = convert.(BigFloat, S_init)
    V_bf = convert.(Complex{BigFloat}, V_init)

    result = ogita_svd_refine(A_bf, U_bf, S_bf, V_bf;
                              max_iterations=5, precision_bits=256)
    # Each point gets distinct, accurate σ_min
end</code></pre><h2 id="When-to-Use-Double64-vs-BigFloat"><a class="docs-heading-anchor" href="#When-to-Use-Double64-vs-BigFloat">When to Use Double64 vs BigFloat</a><a id="When-to-Use-Double64-vs-BigFloat-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Double64-vs-BigFloat" title="Permalink"></a></h2><table><tr><th style="text-align: right">Condition</th><th style="text-align: right">Use Double64?</th><th style="text-align: right">Use BigFloat?</th></tr><tr><td style="text-align: right">σ_min &gt; 1e-10</td><td style="text-align: right">✓ (10-30x faster)</td><td style="text-align: right">Optional</td></tr><tr><td style="text-align: right">1e-14 &lt; σ_min &lt; 1e-10</td><td style="text-align: right">✓ (works)</td><td style="text-align: right">Safer</td></tr><tr><td style="text-align: right">σ_min &lt; 1e-14</td><td style="text-align: right">✗ (residual too large)</td><td style="text-align: right"><strong>Required</strong></td></tr><tr><td style="text-align: right">Sub-ε radius, far from spectrum</td><td style="text-align: right">✓ (works)</td><td style="text-align: right">Optional</td></tr><tr><td style="text-align: right">Sub-ε radius, near spectrum</td><td style="text-align: right">✗ (fails)</td><td style="text-align: right"><strong>Required</strong></td></tr></table><p><strong>Key insight:</strong> The limiting factor is not representing sub-ε differences (Double64 can handle 1e-32), but achieving small enough residual. Double64 residual ≈ 1e-13, BigFloat ≈ 1e-77.</p><p><strong>Practical guideline:</strong></p><ul><li>If Float64 σ_min at center &gt; 1e-12: Double64 is safe</li><li>If Float64 σ_min at center &lt; 1e-12: Use BigFloat</li><li>When in doubt: Use BigFloat (correct but slower)</li></ul><h2 id="Resolved-Questions"><a class="docs-heading-anchor" href="#Resolved-Questions">Resolved Questions</a><a id="Resolved-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Resolved-Questions" title="Permalink"></a></h2><ol><li><p><strong>Optimal precision cascade:</strong> Float64 → Double64 → BigFloat, or skip Double64?</p><ul><li><strong>Answer:</strong> Depends on σ<em>min. For σ</em>min &gt; 1e-10, Double64 provides 10-20x speedup.</li><li>For σ_min &lt; 1e-14 (near eigenvalues), skip Double64 and use BigFloat directly.</li></ul></li><li><p><strong>Warm-start at BigFloat level:</strong> Does reusing BigFloat SVD between adjacent points help?</p><ul><li><strong>Answer:</strong> No. The O(|Δz|) error from warm-start defeats Ogita&#39;s quadratic convergence.</li></ul></li><li><p><strong>Adaptive radius:</strong> Automatically detect when radius &lt; ε and switch to BigFloat workflow?</p><ul><li><strong>Answer:</strong> Yes, this is needed. When <code>radius &lt; 1e-16 * |center|</code>, switch to BigFloat center.</li></ul></li></ol><h2 id="Open-Questions"><a class="docs-heading-anchor" href="#Open-Questions">Open Questions</a><a id="Open-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Open-Questions" title="Permalink"></a></h2><ol><li><p><strong>Integration with adaptive circle splitting:</strong> How does sub-ε certification interact with the adaptive refinement in CertifScripts? Should we add a minimum radius threshold?</p></li><li><p><strong>Performance at sub-ε:</strong> Is there a faster algorithm when all points share the same Float64 approximation? (Currently we compute the same center SVD n times.)</p></li></ol><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Ogita &amp; Aishima (2020): &quot;Iterative refinement for singular value decomposition&quot;</li><li>Bini, Gemignani et al.: Work on tracking eigenvalues through crossings</li><li>Rump &amp; Ogita (2024): Verified SVD computation</li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 31 January 2026 18:10">Saturday 31 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
