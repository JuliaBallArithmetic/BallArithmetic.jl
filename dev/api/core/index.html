<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core Types · BallArithmetic.jl</title><meta name="title" content="Core Types · BallArithmetic.jl"/><meta property="og:title" content="Core Types · BallArithmetic.jl"/><meta property="twitter:title" content="Core Types · BallArithmetic.jl"/><meta name="description" content="Documentation for BallArithmetic.jl."/><meta property="og:description" content="Documentation for BallArithmetic.jl."/><meta property="twitter:description" content="Documentation for BallArithmetic.jl."/><meta property="og:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/core/"/><meta property="twitter:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/core/"/><link rel="canonical" href="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/core/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BallArithmetic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../decompositions/">Matrix Decompositions</a></li><li><a class="tocitem" href="../../svd/">SVD</a></li><li><a class="tocitem" href="../../eigenvalues/">Eigenvalues</a></li><li><a class="tocitem" href="../../pseudospectra/">Pseudospectra</a></li><li><a class="tocitem" href="../../linearsystems/">Linear Systems</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/">Overview</a></li><li class="is-active"><a class="tocitem" href>Core Types</a><ul class="internal"><li><a class="tocitem" href="#Ball-Type"><span>Ball Type</span></a></li><li><a class="tocitem" href="#Array-Types"><span>Array Types</span></a></li><li><a class="tocitem" href="#Norm-Bounds"><span>Norm Bounds</span></a></li><li><a class="tocitem" href="#Oishi-2023-Schur-Complement-Bounds"><span>Oishi 2023 Schur Complement Bounds</span></a></li><li><a class="tocitem" href="#Rump-Oishi-2024-Improved-Schur-Complement-Bounds"><span>Rump-Oishi 2024 Improved Schur Complement Bounds</span></a></li></ul></li><li><a class="tocitem" href="../linearsystems/">Linear Systems</a></li><li><a class="tocitem" href="../eigenvalues/">Eigenvalues &amp; SVD</a></li><li><a class="tocitem" href="../certifscripts/">CertifScripts</a></li><li><a class="tocitem" href="../numericaltest/">NumericalTest</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Core Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core Types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/main/docs/src/api/core.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Core-Types"><a class="docs-heading-anchor" href="#API-Core-Types">API - Core Types</a><a id="API-Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#API-Core-Types" title="Permalink"></a></h1><p>Core ball arithmetic types and basic operations.</p><h2 id="Ball-Type"><a class="docs-heading-anchor" href="#Ball-Type">Ball Type</a><a id="Ball-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Ball-Type" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.Ball"><a class="docstring-binding" href="#BallArithmetic.Ball"><code>BallArithmetic.Ball</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ball{T, CT}</code></pre><p>Closed floating-point ball with midpoint type <code>CT</code> and radius type <code>T</code>. Each value represents the set <code>{ c + δ : |δ| ≤ r }</code> where <code>c::CT</code> is the stored midpoint and <code>r::T ≥ 0</code> is the radius. Both real and complex midpoints are supported as long as the radius is expressed in the underlying real field. The type behaves as a number and participates in arithmetic with rigorous outward rounding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.BallF64"><a class="docstring-binding" href="#BallArithmetic.BallF64"><code>BallArithmetic.BallF64</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ball{T, CT}</code></pre><p>Closed floating-point ball with midpoint type <code>CT</code> and radius type <code>T</code>. Each value represents the set <code>{ c + δ : |δ| ≤ r }</code> where <code>c::CT</code> is the stored midpoint and <code>r::T ≥ 0</code> is the radius. Both real and complex midpoints are supported as long as the radius is expressed in the underlying real field. The type behaves as a number and participates in arithmetic with rigorous outward rounding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.BallComplexF64"><a class="docstring-binding" href="#BallArithmetic.BallComplexF64"><code>BallArithmetic.BallComplexF64</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ball{T, CT}</code></pre><p>Closed floating-point ball with midpoint type <code>CT</code> and radius type <code>T</code>. Each value represents the set <code>{ c + δ : |δ| ≤ r }</code> where <code>c::CT</code> is the stored midpoint and <code>r::T ≥ 0</code> is the radius. Both real and complex midpoints are supported as long as the radius is expressed in the underlying real field. The type behaves as a number and participates in arithmetic with rigorous outward rounding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.mid"><a class="docstring-binding" href="#BallArithmetic.mid"><code>BallArithmetic.mid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mid(x)</code></pre><p>Return the midpoint of <code>x</code>. For plain numbers the midpoint is the value itself, while for balls the stored center is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L53-L58">source</a></section><section><div><pre><code class="language-julia hljs">mid(v::AbstractVector{&lt;:Ball})</code></pre><p>Return a vector of midpoints for a collection of balls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L86-L90">source</a></section><section><div><pre><code class="language-julia hljs">mid(M::AbstractMatrix{&lt;:Ball})</code></pre><p>Return a matrix of midpoints for a collection of balls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L93-L97">source</a></section><section><div><pre><code class="language-julia hljs">mid(A::AbstractArray)</code></pre><p>Fallback definition that treats ordinary arrays as their own midpoint representation. Specialisations for <code>BallArray</code> overload this method to return the stored midpoint data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/array.jl#L35-L41">source</a></section><section><div><pre><code class="language-julia hljs">mid(A::BallArray)</code></pre><p>Return the stored midpoint array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/array.jl#L68-L72">source</a></section><section><div><pre><code class="language-julia hljs">mid(A::AbstractMatrix)</code></pre><p>Return the midpoint matrix associated with <code>A</code>. For plain matrices the midpoint equals the matrix itself; for <code>BallMatrix</code> values this method is extended elsewhere to extract the stored midpoint data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/matrix.jl#L69-L75">source</a></section><section><div><pre><code class="language-julia hljs">mid(v::AbstractVector)</code></pre><p>Treat ordinary vectors as their own midpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/vector.jl#L39-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rad"><a class="docstring-binding" href="#BallArithmetic.rad"><code>BallArithmetic.rad</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rad(x)</code></pre><p>Return the radius associated with <code>x</code>. Numbers default to a zero radius, and balls return their stored uncertainty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L62-L67">source</a></section><section><div><pre><code class="language-julia hljs">rad(v::AbstractVector{&lt;:Ball})</code></pre><p>Return a vector of radii for a collection of balls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L72-L76">source</a></section><section><div><pre><code class="language-julia hljs">rad(M::AbstractMatrix{&lt;:Ball})</code></pre><p>Return a matrix of radii for a collection of balls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L79-L83">source</a></section><section><div><pre><code class="language-julia hljs">rad(A::AbstractArray)</code></pre><p>Return a zero array of matching size that serves as the default radius for non-ball arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/array.jl#L44-L49">source</a></section><section><div><pre><code class="language-julia hljs">rad(A::BallArray)</code></pre><p>Return the stored radius array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/array.jl#L75-L79">source</a></section><section><div><pre><code class="language-julia hljs">rad(A::AbstractMatrix{T})</code></pre><p>Return a matrix of radii matching the size of <code>A</code>. For non-ball matrices this defaults to a zero matrix, while for <code>BallMatrix</code> values the method is overloaded to provide the stored uncertainty information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/matrix.jl#L78-L84">source</a></section><section><div><pre><code class="language-julia hljs">rad(A::AbstractMatrix{Complex{T}})</code></pre><p>Return a matrix of real radii matching the size of the complex matrix <code>A</code>. Even for complex entries the radius is measured over the underlying real field, hence the resulting matrix has element type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/matrix.jl#L88-L94">source</a></section><section><div><pre><code class="language-julia hljs">rad(v::AbstractVector)</code></pre><p>Default radius for non-ball vectors: a zero vector of the appropriate floating-point type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/vector.jl#L46-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.midtype"><a class="docstring-binding" href="#BallArithmetic.midtype"><code>BallArithmetic.midtype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">midtype(::Ball)</code></pre><p>Return the type used to store the midpoint component of a <code>Ball</code>. This is useful for allocating arrays that mirror the internal layout of a ball or a collection of balls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L100-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.radtype"><a class="docstring-binding" href="#BallArithmetic.radtype"><code>BallArithmetic.radtype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">radtype(x)</code></pre><p>Return the floating-point type used to store radii for <code>x</code>. The helper accepts either a ball instance or the associated type, mirroring the behaviour of <a href="#BallArithmetic.midtype"><code>midtype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L111-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.inf"><a class="docstring-binding" href="#BallArithmetic.inf"><code>BallArithmetic.inf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inf(x::Ball)</code></pre><p>Return the infimum (lower endpoint) of the set represented by <code>x</code> by evaluating <code>mid(x) - rad(x)</code> with downward rounding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L130-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.sup"><a class="docstring-binding" href="#BallArithmetic.sup"><code>BallArithmetic.sup</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sup(x::Ball)</code></pre><p>Return the supremum (upper endpoint) of the set represented by <code>x</code> by evaluating <code>mid(x) + rad(x)</code> with outward rounding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L122-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.ball_hull"><a class="docstring-binding" href="#BallArithmetic.ball_hull"><code>BallArithmetic.ball_hull</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ball_hull(a::Ball, b::Ball)</code></pre><p>Return the smallest ball that contains both <code>a</code> and <code>b</code>. For real centres the function encloses the convex hull on the real line. When the midpoints are complex the result encloses both discs while keeping the centre as close as possible to one of the inputs so that subsequent operations remain stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L144-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.intersect_ball"><a class="docstring-binding" href="#BallArithmetic.intersect_ball"><code>BallArithmetic.intersect_ball</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intersect_ball(a::Ball, b::Ball)</code></pre><p>Return the intersection of the real balls <code>a</code> and <code>b</code>. When the balls do not overlap the function returns <code>nothing</code> to indicate that the intersection is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/ball.jl#L187-L193">source</a></section></details></article><h2 id="Array-Types"><a class="docs-heading-anchor" href="#Array-Types">Array Types</a><a id="Array-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.BallArray"><a class="docstring-binding" href="#BallArithmetic.BallArray"><code>BallArithmetic.BallArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BallArray{T, N, NT, BT, CA, RA}</code></pre><p>Multi-dimensional array whose entries are <a href="#BallArithmetic.Ball"><code>Ball</code></a> values. The type stores midpoint data <code>c::CA</code> and radius data <code>r::RA</code> separately while presenting an <code>AbstractArray{BT, N}</code> interface that behaves like an array of balls. The parameters mirror the element type and storage layout and are inferred automatically from the provided midpoint and radius containers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/array.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.BallMatrix"><a class="docstring-binding" href="#BallArithmetic.BallMatrix"><code>BallArithmetic.BallMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BallMatrix{T, NT, BT, CM, RM}</code></pre><p>Alias for the two-dimensional <a href="#BallArithmetic.BallArray"><code>BallArray</code></a> used to represent matrices with rigorous error control. The type parameters mirror those of <code>BallArray</code> and describe the base floating-point type <code>T</code>, the element type <code>NT</code>, the <a href="#BallArithmetic.Ball"><code>Ball</code></a> container <code>BT</code>, and the concrete matrix types used for the midpoints (<code>CM</code>) and radii (<code>RM</code>).</p><p>Users typically construct instances through the <code>BallMatrix</code> constructors below rather than specifying these parameters explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/matrix.jl#L15-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.BallVector"><a class="docstring-binding" href="#BallArithmetic.BallVector"><code>BallArithmetic.BallVector</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BallVector{T, NT, BT, CM, RM}</code></pre><p>Alias for the one-dimensional <a href="#BallArithmetic.BallArray"><code>BallArray</code></a>, representing vectors of balls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/types/vector.jl#L1-L6">source</a></section></details></article><h2 id="Norm-Bounds"><a class="docs-heading-anchor" href="#Norm-Bounds">Norm Bounds</a><a id="Norm-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Norm-Bounds" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.upper_bound_norm"><a class="docstring-binding" href="#BallArithmetic.upper_bound_norm"><code>BallArithmetic.upper_bound_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">upper_bound_norm(A::BallMatrix, p::Real = 2)</code></pre><p>Compute a rigorous upper bound for the p-norm of a <code>BallMatrix</code> by computing the norm of the midpoint and radius arrays with upward rounding. The default <code>p = 2</code> corresponds to the Frobenius norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rigorous_norm.jl#L19-L25">source</a></section><section><div><pre><code class="language-julia hljs">upper_bound_norm(v::BallVector, p::Real = 2)</code></pre><p>Compute a rigorous upper bound for the p-norm of a <code>BallVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rigorous_norm.jl#L30-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.upper_bound_L1_opnorm"><a class="docstring-binding" href="#BallArithmetic.upper_bound_L1_opnorm"><code>BallArithmetic.upper_bound_L1_opnorm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">upper_bound_L1_opnorm(A::BallMatrix{T})</code></pre><p>Returns a rigorous upper bound on the ℓ¹-norm of the ball matrix <code>A</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rigorous_opnorm_bounds.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.upper_bound_L2_opnorm"><a class="docstring-binding" href="#BallArithmetic.upper_bound_L2_opnorm"><code>BallArithmetic.upper_bound_L2_opnorm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">upper_bound_L_inf_opnorm(A::BallMatrix{T})</code></pre><p>Returns a rigorous upper bound on the ℓ²-norm of the ball matrix <code>A</code> using the best between the Collatz bound and the interpolation bound</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rigorous_opnorm_bounds.jl#L91-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.upper_bound_L_inf_opnorm"><a class="docstring-binding" href="#BallArithmetic.upper_bound_L_inf_opnorm"><code>BallArithmetic.upper_bound_L_inf_opnorm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">upper_bound_L_inf_opnorm(A::BallMatrix{T})</code></pre><p>Returns a rigorous upper bound on the ℓ-∞-norm of the ball matrix <code>A</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rigorous_opnorm_bounds.jl#L79-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.collatz_upper_bound_L2_opnorm"><a class="docstring-binding" href="#BallArithmetic.collatz_upper_bound_L2_opnorm"><code>BallArithmetic.collatz_upper_bound_L2_opnorm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">collatz_upper_bound_L2_opnorm(A::BallMatrix; iterates=10)</code></pre><p>Give a rigorous upper bound on the ℓ² norm of the matrix <code>A</code> by using the Collatz theorem.</p><p>We use Perron theory here: if for two matrices with <code>B</code> positive <code>|A| &lt; B</code> we have ρ(A)&lt;=ρ(B) by Wielandt&#39;s theorem <a href="https://mathworld.wolfram.com/WielandtsTheorem.html">Wielandt&#39;s theorem</a></p><p>The keyword argument <code>iterates</code> is used to establish how many times we are iterating the vector of ones before we use Collatz&#39;s estimate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rigorous_opnorm_bounds.jl#L18-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.svd_bound_L2_opnorm"><a class="docstring-binding" href="#BallArithmetic.svd_bound_L2_opnorm"><code>BallArithmetic.svd_bound_L2_opnorm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_bound_L2_opnorm(A::BallMatrix{T})</code></pre><p>Returns a rigorous upper bound on the ℓ²-norm (spectral norm) of the ball matrix <code>A</code> using the rigorous SVD enclosure from <a href="../eigenvalues/#BallArithmetic.rigorous_svd"><code>rigorous_svd</code></a>.</p><p>This method computes the largest certified singular value, providing the tightest possible upper bound on <code>‖A‖₂</code>. The bound is essentially exact (typically &lt;0.01% overestimation), but requires O(n³) computation for the SVD.</p><p><strong>Comparison with other L2 norm methods</strong></p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Speed</th><th style="text-align: right">Accuracy</th><th style="text-align: right">Best use case</th></tr><tr><td style="text-align: right"><code>svd_bound_L2_opnorm</code></td><td style="text-align: right">O(n³)</td><td style="text-align: right">~0% overest.</td><td style="text-align: right">When accuracy is critical</td></tr><tr><td style="text-align: right"><code>collatz_upper_bound_L2_opnorm</code></td><td style="text-align: right">Fast</td><td style="text-align: right">0-500% overest.*</td><td style="text-align: right">Structured matrices</td></tr><tr><td style="text-align: right"><code>upper_bound_L2_opnorm</code></td><td style="text-align: right">Fast</td><td style="text-align: right">min of above</td><td style="text-align: right">General use</td></tr></table><p>*Collatz performs well on structured matrices (tridiagonal: ~0%, Hilbert: ~0%, diagonally dominant: ~26%) but poorly on random matrices (~200-500%).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix(randn(50, 50))
bound = svd_bound_L2_opnorm(A)  # Tight bound, slower
fast_bound = upper_bound_L2_opnorm(A)  # Looser bound, faster</code></pre><p>See also: <a href="#BallArithmetic.upper_bound_L2_opnorm"><code>upper_bound_L2_opnorm</code></a>, <a href="#BallArithmetic.collatz_upper_bound_L2_opnorm"><code>collatz_upper_bound_L2_opnorm</code></a>, <a href="../eigenvalues/#BallArithmetic.rigorous_svd"><code>rigorous_svd</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rigorous_opnorm_bounds.jl#L105-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rump_oishi_2024_triangular_bound"><a class="docstring-binding" href="#BallArithmetic.rump_oishi_2024_triangular_bound"><code>BallArithmetic.rump_oishi_2024_triangular_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rump_oishi_2024_triangular_bound(T::BallMatrix, k::Int; method=:hybrid)</code></pre><p>Compute rigorous upper bound on <code>‖T[1:k,:]⁻¹‖₂</code> for upper triangular <code>T</code>.</p><p>Implements the bounds from RumpOishi2024 with improved handling of the Collatz spectral radius estimate for triangular matrices.</p><p><strong>Arguments</strong></p><ul><li><code>T::BallMatrix</code>: Upper triangular ball matrix</li><li><code>k::Int</code>: Block size (compute bound for first k rows/columns)</li><li><code>method::Symbol</code>: Method to use<ul><li><code>:psi</code> - ψ-bound method (original RumpOishi2024)</li><li><code>:backward</code> - Backward substitution method</li><li><code>:hybrid</code> - Use best of both methods (default)</li></ul></li></ul><p><strong>Method Details</strong></p><p><strong>Ψ-bound method:</strong></p><p>For block structure <code>T = [A B; 0 D]</code> where <code>A</code> is k×k:</p><ol><li>Compute <code>E = A⁻¹B</code> via backward substitution</li><li>Compute <code>F = D_d⁻¹ D_f</code> where <code>D = D_d + D_f</code> (diagonal + off-diagonal)</li><li>Estimate using ψ bounds: <code>‖T⁻¹‖ ≤ max(α, β) · ψ(E)</code> where α = ‖A⁻¹‖, β = ‖D_d⁻¹‖/(1-‖F‖)</li></ol><p><strong>Backward substitution method:</strong></p><p>Recursively compute bounds for singular values using: <code>σᵢ = (1/|dᵢᵢ|) · √(1 + ‖bᵢ‖² · σᵢ₊₁²)</code> where <code>bᵢ</code> is the i-th row tail and <code>dᵢᵢ</code> is the i-th diagonal.</p><p><strong>Returns</strong></p><p>Rigorous upper bound on <code>‖T[1:k,:]⁻¹‖₂</code> as a floating-point number.</p><p><strong>Reference</strong></p><ul><li>Rump &amp; Oishi (2024), &quot;A Note on Oishi&#39;s Lower Bound...&quot;, SIAM J. Matrix Anal. Appl.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rump_oishi_2024.jl#L7-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.backward_singular_value_bound"><a class="docstring-binding" href="#BallArithmetic.backward_singular_value_bound"><code>BallArithmetic.backward_singular_value_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">backward_singular_value_bound(A::BallMatrix)</code></pre><p>Compute rigorous upper bounds for singular values of upper triangular matrix using backward recursion.</p><p>For upper triangular A, computes bounds σᵢ such that σᵢ(A) ≤ σᵢ for i=1,...,n using the recursion:</p><pre><code class="language-julia hljs">σᵢ = (1/|aᵢᵢ|) · √(1 + ‖row_tail_i‖² · σᵢ₊₁²)</code></pre><p>starting from σₙ₊₁ = 0.</p><p><strong>Reference</strong></p><ul><li>RumpOishi2024, Theorem 3.2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/rump_oishi_2024.jl#L321-L336">source</a></section></details></article><h3 id="L2-Operator-Norm:-Method-Comparison"><a class="docs-heading-anchor" href="#L2-Operator-Norm:-Method-Comparison">L2 Operator Norm: Method Comparison</a><a id="L2-Operator-Norm:-Method-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#L2-Operator-Norm:-Method-Comparison" title="Permalink"></a></h3><p>The package provides several methods for computing rigorous upper bounds on <code>‖A‖₂</code>:</p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Complexity</th><th style="text-align: right">Accuracy</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>svd_bound_L2_opnorm</code></td><td style="text-align: right">O(n³)</td><td style="text-align: right">Exact (~0%)</td><td style="text-align: right">Computes rigorous SVD, returns largest σ</td></tr><tr><td style="text-align: right"><code>collatz_upper_bound_L2_opnorm</code></td><td style="text-align: right">O(k·n²)</td><td style="text-align: right">0-500%*</td><td style="text-align: right">Iterative power method on |A|ᵀ|A|</td></tr><tr><td style="text-align: right"><code>sqrt(‖·‖₁·‖·‖∞)</code></td><td style="text-align: right">O(n²)</td><td style="text-align: right">87-564%</td><td style="text-align: right">Uses <code>‖A‖₂ ≤ √(‖A‖₁·‖A‖∞)</code></td></tr><tr><td style="text-align: right"><code>upper_bound_L2_opnorm</code></td><td style="text-align: right">O(k·n²)</td><td style="text-align: right">min of above</td><td style="text-align: right">Takes minimum of Collatz and sqrt</td></tr></table><p>*Collatz accuracy depends heavily on matrix structure:</p><ul><li><strong>Tridiagonal/banded</strong>: ~0% overestimation (essentially exact)</li><li><strong>Hilbert-like matrices</strong>: ~0% overestimation</li><li><strong>Diagonally dominant</strong>: ~26% overestimation</li><li><strong>Random dense matrices</strong>: 200-500% overestimation</li></ul><h4 id="Benchmark-Results-(nn-matrices)"><a class="docs-heading-anchor" href="#Benchmark-Results-(nn-matrices)">Benchmark Results (n×n matrices)</a><a id="Benchmark-Results-(nn-matrices)-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-Results-(nn-matrices)" title="Permalink"></a></h4><pre><code class="nohighlight hljs">Matrix type               Collatz   sqrt(‖·‖₁·‖·‖∞)   SVD bound
─────────────────────────────────────────────────────────────────
Random (n=50)             186%      249%              0%
Diagonally dominant       26%       36%               0%
Tridiagonal               0.1%      0.1%              0%
Symmetric positive def.   140%      230%              0%
Low rank + noise          54%       143%              0%
Hilbert-like              0%        117%              0%</code></pre><h4 id="Recommendations"><a class="docs-heading-anchor" href="#Recommendations">Recommendations</a><a id="Recommendations-1"></a><a class="docs-heading-anchor-permalink" href="#Recommendations" title="Permalink"></a></h4><ul><li><strong>General use</strong>: <code>upper_bound_L2_opnorm</code> (fast, takes best of cheap bounds)</li><li><strong>Accuracy critical</strong>: <code>svd_bound_L2_opnorm</code> (exact but O(n³))</li><li><strong>Structured matrices</strong>: <code>collatz_upper_bound_L2_opnorm</code> often gives near-exact results</li></ul><h2 id="Oishi-2023-Schur-Complement-Bounds"><a class="docs-heading-anchor" href="#Oishi-2023-Schur-Complement-Bounds">Oishi 2023 Schur Complement Bounds</a><a id="Oishi-2023-Schur-Complement-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Oishi-2023-Schur-Complement-Bounds" title="Permalink"></a></h2><p>Lower bounds on minimum singular values using the Schur complement method from Oishi (2023), &quot;Lower bounds for the smallest singular values of generalized asymptotic diagonal dominant matrices&quot;.</p><article><details class="docstring" open="true"><summary id="BallArithmetic.Oishi2023Result"><a class="docstring-binding" href="#BallArithmetic.Oishi2023Result"><code>BallArithmetic.Oishi2023Result</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Oishi2023Result{T}</code></pre><p>Result from the Oishi 2023 Schur complement bound computation.</p><p><strong>Fields</strong></p><ul><li><code>sigma_min_lower</code>: Rigorous lower bound on the minimum singular value</li><li><code>G_inv_upper</code>: Upper bound on ‖G⁻¹‖₂ (= 1/σ_min)</li><li><code>A_inv_norm</code>: Upper bound on ‖A⁻¹‖₂</li><li><code>A_inv_B_norm</code>: Upper bound on ‖A⁻¹B‖₂</li><li><code>C_A_inv_norm</code>: Upper bound on ‖CA⁻¹‖₂</li><li><code>schur_contraction</code>: Upper bound on ‖D<em>d⁻¹(D</em>f - CA⁻¹B)‖₂</li><li><code>verified</code>: Whether all conditions of Theorem 1 are satisfied</li><li><code>block_size</code>: The block size m used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L12-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.oishi_2023_sigma_min_bound"><a class="docstring-binding" href="#BallArithmetic.oishi_2023_sigma_min_bound"><code>BallArithmetic.oishi_2023_sigma_min_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">oishi_2023_sigma_min_bound(G::BallMatrix{T}, m::Int) where {T}</code></pre><p>Compute a rigorous lower bound on the minimum singular value of G using the Schur complement method from Oishi (2023).</p><p><strong>Arguments</strong></p><ul><li><code>G::BallMatrix</code>: The matrix to analyze</li><li><code>m::Int</code>: Block size for the partition (A is m×m)</li></ul><p><strong>Method (Theorem 1 from Oishi 2023)</strong></p><p>Partition G as:</p><pre><code class="language-julia hljs">G = [A  B]
    [C  D]</code></pre><p>where A ∈ M<em>m, B ∈ M</em>{m,n-m}, C ∈ M<em>{n-m,m}, D ∈ M</em>{n-m,n-m}.</p><p>Let D<em>d and D</em>f be the diagonal and off-diagonal parts of D.</p><p>If the following conditions hold:</p><ol><li>‖A⁻¹B‖₂ &lt; 1</li><li>‖CA⁻¹‖₂ &lt; 1</li><li>‖D<em>d⁻¹(D</em>f - CA⁻¹B)‖₂ &lt; 1</li></ol><p>Then G is invertible and:</p><pre><code class="language-julia hljs">‖G⁻¹‖₂ ≤ max{‖A⁻¹‖₂, ‖D_d⁻¹‖₂/(1 - ‖D_d⁻¹(D_f - CA⁻¹B)‖₂)}
         / ((1 - ‖A⁻¹B‖₂)(1 - ‖CA⁻¹‖₂))</code></pre><p>Since σ<em>min(G) = 1/‖G⁻¹‖₂, this gives a lower bound on σ</em>min.</p><p><strong>Returns</strong></p><p><code>Oishi2023Result</code> containing the bounds and verification status.</p><p><strong>Reference</strong></p><p>Oishi, S. (2023), Japan J. Indust. Appl. Math. 40:1569-1585</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L75-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.oishi_2023_optimal_block_size"><a class="docstring-binding" href="#BallArithmetic.oishi_2023_optimal_block_size"><code>BallArithmetic.oishi_2023_optimal_block_size</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">oishi_2023_optimal_block_size(G::BallMatrix{T}; max_m::Int=100) where {T}</code></pre><p>Find the optimal block size m that gives the tightest bound on σ_min.</p><p>Returns a tuple (best<em>m, best</em>result).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L368-L374">source</a></section></details></article><h2 id="Rump-Oishi-2024-Improved-Schur-Complement-Bounds"><a class="docs-heading-anchor" href="#Rump-Oishi-2024-Improved-Schur-Complement-Bounds">Rump-Oishi 2024 Improved Schur Complement Bounds</a><a id="Rump-Oishi-2024-Improved-Schur-Complement-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Rump-Oishi-2024-Improved-Schur-Complement-Bounds" title="Permalink"></a></h2><p>Improved bounds from Rump &amp; Oishi (2024), &quot;A Note on Oishi&#39;s Lower Bound for the Smallest Singular Value of Linearized Galerkin Equations&quot;.</p><h3 id="Key-Improvements-over-Oishi-2023"><a class="docs-heading-anchor" href="#Key-Improvements-over-Oishi-2023">Key Improvements over Oishi 2023</a><a id="Key-Improvements-over-Oishi-2023-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Improvements-over-Oishi-2023" title="Permalink"></a></h3><ol><li><p><strong>Removes conditions 1 &amp; 2</strong>: No longer requires <code>‖A⁻¹B‖ &lt; 1</code> and <code>‖CA⁻¹‖ &lt; 1</code>. Only condition 3 (<code>‖Dd⁻¹(Df - CA⁻¹B)‖ &lt; 1</code>) is needed.</p></li><li><p><strong>Uses exact ψ(N) formula</strong>: Instead of <code>1/(1-‖N‖)</code>, uses <code>ψ(μ) = √(1 + 2αμ√(1-α²) + α²μ²)</code> which is tighter and works for any <code>μ ≥ 0</code>.</p></li><li><p><strong>Fast γ bound</strong> (optional): Uses <code>π(N) = √(‖N‖₁·‖N‖∞)</code> to quickly check if the method will succeed, avoiding expensive matrix products and reducing complexity from O((n-m)²m) to O((n-m)m²).</p></li></ol><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs">using BallArithmetic, LinearAlgebra

# Create a diagonally dominant matrix (Example 3 from paper)
k, n = 0.9, 50
G_mid = [i == j ? Float64(i) : k^abs(i-j) for i in 1:n, j in 1:n]
G = BallMatrix(G_mid, zeros(n, n))

# Compute bounds with optimal block size
best_m, result = rump_oishi_2024_optimal_block_size(G; max_m=30)

if result.verified
    println(&quot;σ_min(G) ≥ &quot;, result.sigma_min_lower)
    println(&quot;‖G⁻¹‖ ≤ &quot;, result.G_inv_upper)
    println(&quot;Optimal block size: m = &quot;, best_m)
    println(&quot;Used fast γ bound: &quot;, result.used_fast_gamma)
end</code></pre><h3 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="BallArithmetic.RumpOishi2024Result"><a class="docstring-binding" href="#BallArithmetic.RumpOishi2024Result"><code>BallArithmetic.RumpOishi2024Result</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RumpOishi2024Result{T}</code></pre><p>Result from the Rump-Oishi 2024 improved Schur complement bound computation.</p><p>This improves upon Oishi 2023 by:</p><ol><li>Removing the conditions ‖A⁻¹B‖ &lt; 1 and ‖CA⁻¹‖ &lt; 1</li><li>Using the exact ψ(N) formula instead of 1/(1-‖N‖)</li><li>Optionally using a fast γ bound to avoid expensive matrix products</li></ol><p><strong>Fields</strong></p><ul><li><code>sigma_min_lower</code>: Rigorous lower bound on the minimum singular value</li><li><code>G_inv_upper</code>: Upper bound on ‖G⁻¹‖₂ (= 1/σ_min)</li><li><code>A_inv_norm</code>: Upper bound on ‖A⁻¹‖₂</li><li><code>psi_A_inv_B</code>: ψ(‖A⁻¹B‖₂) factor</li><li><code>psi_C_A_inv</code>: ψ(‖CA⁻¹‖₂) factor</li><li><code>schur_contraction</code>: Upper bound on ‖D<em>d⁻¹(D</em>f - CA⁻¹B)‖₂</li><li><code>used_fast_gamma</code>: Whether the fast γ bound was used</li><li><code>verified</code>: Whether the method succeeded (only requires schur_contraction &lt; 1)</li><li><code>block_size</code>: The block size m used</li></ul><p><strong>Reference</strong></p><p>Rump, S.M. &amp; Oishi, S. (2024), &quot;A Note on Oishi&#39;s Lower Bound for the Smallest Singular Value of Linearized Galerkin Equations&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L38-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rump_oishi_2024_sigma_min_bound"><a class="docstring-binding" href="#BallArithmetic.rump_oishi_2024_sigma_min_bound"><code>BallArithmetic.rump_oishi_2024_sigma_min_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rump_oishi_2024_sigma_min_bound(G::BallMatrix{T}, m::Int;
                                 try_fast_gamma::Bool=true) where {T}</code></pre><p>Compute a rigorous lower bound on the minimum singular value of G using the improved Schur complement method from Rump-Oishi (2024).</p><p><strong>Arguments</strong></p><ul><li><code>G::BallMatrix</code>: The matrix to analyze</li><li><code>m::Int</code>: Block size for the partition (A is m×m)</li><li><code>try_fast_gamma::Bool=true</code>: Whether to try the fast γ bound first</li></ul><p><strong>Improvements over Oishi 2023</strong></p><ol><li><p><strong>Removes conditions 1 &amp; 2</strong>: No longer requires ‖A⁻¹B‖ &lt; 1 and ‖CA⁻¹‖ &lt; 1. Only condition 3 (‖Dd⁻¹(Df - CA⁻¹B)‖ &lt; 1) is needed.</p></li><li><p><strong>Uses exact ψ(N) formula</strong>: Instead of 1/(1-‖N‖), uses ψ(μ) = √(1 + 2αμ√(1-α²) + α²μ²) which is tighter and works for any μ ≥ 0.</p></li><li><p><strong>Fast γ bound</strong> (optional): Uses π(N) = √(‖N‖₁·‖N‖∞) to quickly check if the method will succeed, avoiding expensive matrix products.</p></li></ol><p><strong>Method (Theorem 1.3 from Rump-Oishi 2024)</strong></p><p>Partition G as:</p><pre><code class="language-julia hljs">G = [A  B]
    [C  D]</code></pre><p>If ‖Dd⁻¹(Df - CA⁻¹B)‖ &lt; 1, then:</p><pre><code class="language-julia hljs">‖G⁻¹‖ ≤ max{‖A⁻¹‖, ‖Dd⁻¹‖/(1 - ‖Dd⁻¹(Df - CA⁻¹B)‖)} · ψ(‖A⁻¹B‖) · ψ(‖CA⁻¹‖)</code></pre><p><strong>Returns</strong></p><p><code>RumpOishi2024Result</code> containing the bounds and verification status.</p><p><strong>Reference</strong></p><p>Rump, S.M. &amp; Oishi, S. (2024), &quot;A Note on Oishi&#39;s Lower Bound for the Smallest Singular Value of Linearized Galerkin Equations&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L509-L553">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rump_oishi_2024_optimal_block_size"><a class="docstring-binding" href="#BallArithmetic.rump_oishi_2024_optimal_block_size"><code>BallArithmetic.rump_oishi_2024_optimal_block_size</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rump_oishi_2024_optimal_block_size(G::BallMatrix{T}; max_m::Int=100,
                                    try_fast_gamma::Bool=true) where {T}</code></pre><p>Find the optimal block size m that gives the tightest bound on σ_min using the Rump-Oishi 2024 method.</p><p>Returns a tuple (best<em>m, best</em>result).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L690-L698">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.psi_schur_factor"><a class="docstring-binding" href="#BallArithmetic.psi_schur_factor"><code>BallArithmetic.psi_schur_factor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">psi_schur_factor(μ::T) where {T}</code></pre><p>Compute ψ(μ) from Lemma 1.2 of Rump-Oishi 2024.</p><p>For a block triangular matrix H = [I, -N; 0, I] with ‖N‖ = μ, this computes the exact value of ‖H‖ = ‖H⁻¹‖.</p><p>The formula is:     α = √(½(1 + 1/√(1 + 4/μ²)))     ψ(μ) = √(1 + 2αμ√(1-α²) + α²μ²)</p><p>This replaces the weaker bound 1/(1-μ) used in Oishi 2023, and works for any μ ≥ 0 (no restriction μ &lt; 1).</p><p><strong>Returns</strong></p><p>ψ(μ) as an upper bound (computed with directed rounding).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L397-L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.pi_norm"><a class="docstring-binding" href="#BallArithmetic.pi_norm"><code>BallArithmetic.pi_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pi_norm(M::BallMatrix{T}) where {T}</code></pre><p>Compute π(M) = √(‖M‖₁ · ‖M‖∞), an upper bound on ‖M‖₂.</p><p>This is a cheap bound useful for the fast γ estimate in Rump-Oishi 2024.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/norm_bounds/oishi_2023_schur.jl#L442-L448">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../API/">« Overview</a><a class="docs-footer-nextpage" href="../linearsystems/">Linear Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 22:49">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
