<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Eigenvalues &amp; SVD · BallArithmetic.jl</title><meta name="title" content="Eigenvalues &amp; SVD · BallArithmetic.jl"/><meta property="og:title" content="Eigenvalues &amp; SVD · BallArithmetic.jl"/><meta property="twitter:title" content="Eigenvalues &amp; SVD · BallArithmetic.jl"/><meta name="description" content="Documentation for BallArithmetic.jl."/><meta property="og:description" content="Documentation for BallArithmetic.jl."/><meta property="twitter:description" content="Documentation for BallArithmetic.jl."/><meta property="og:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/eigenvalues/"/><meta property="twitter:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/eigenvalues/"/><link rel="canonical" href="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/eigenvalues/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BallArithmetic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../decompositions/">Matrix Decompositions</a></li><li><a class="tocitem" href="../../svd/">SVD</a></li><li><a class="tocitem" href="../../eigenvalues/">Eigenvalues</a></li><li><a class="tocitem" href="../../pseudospectra/">Pseudospectra</a></li><li><a class="tocitem" href="../../linearsystems/">Linear Systems</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/">Overview</a></li><li><a class="tocitem" href="../core/">Core Types</a></li><li><a class="tocitem" href="../linearsystems/">Linear Systems</a></li><li class="is-active"><a class="tocitem" href>Eigenvalues &amp; SVD</a><ul class="internal"><li><a class="tocitem" href="#Standard-Eigenvalues"><span>Standard Eigenvalues</span></a></li><li><a class="tocitem" href="#Rump-2022a-Method"><span>Rump 2022a Method</span></a></li><li><a class="tocitem" href="#Rump-Lange-2023-Method"><span>Rump-Lange 2023 Method</span></a></li><li><a class="tocitem" href="#Generalized-Eigenvalues"><span>Generalized Eigenvalues</span></a></li><li><a class="tocitem" href="#Singular-Value-Decomposition"><span>Singular Value Decomposition</span></a></li><li><a class="tocitem" href="#Miyajima-VBD"><span>Miyajima VBD</span></a></li><li><a class="tocitem" href="#Adaptive-Ogita-SVD"><span>Adaptive Ogita SVD</span></a></li><li><a class="tocitem" href="#SVD-Caching"><span>SVD Caching</span></a></li><li><a class="tocitem" href="#Spectral-Projectors"><span>Spectral Projectors</span></a></li><li><a class="tocitem" href="#Block-Schur-Decomposition"><span>Block Schur Decomposition</span></a></li><li><a class="tocitem" href="#Schur-Spectral-Projectors"><span>Schur Spectral Projectors</span></a></li><li><a class="tocitem" href="#Schur-Refinement"><span>Schur Refinement</span></a></li><li><a class="tocitem" href="#Riesz-Projections"><span>Riesz Projections</span></a></li><li><a class="tocitem" href="#Singular-Value-Intervals"><span>Singular Value Intervals</span></a></li></ul></li><li><a class="tocitem" href="../certifscripts/">CertifScripts</a></li><li><a class="tocitem" href="../numericaltest/">NumericalTest</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Eigenvalues &amp; SVD</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Eigenvalues &amp; SVD</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/main/docs/src/api/eigenvalues.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Eigenvalues-and-SVD"><a class="docs-heading-anchor" href="#API-Eigenvalues-and-SVD">API - Eigenvalues &amp; SVD</a><a id="API-Eigenvalues-and-SVD-1"></a><a class="docs-heading-anchor-permalink" href="#API-Eigenvalues-and-SVD" title="Permalink"></a></h1><p>Verified eigenvalue and singular value computation.</p><h2 id="Standard-Eigenvalues"><a class="docs-heading-anchor" href="#Standard-Eigenvalues">Standard Eigenvalues</a><a id="Standard-Eigenvalues-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Eigenvalues" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.RigorousEigenvaluesResult"><a class="docstring-binding" href="#BallArithmetic.RigorousEigenvaluesResult"><code>BallArithmetic.RigorousEigenvaluesResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RigorousEigenvaluesResult</code></pre><p>Container returned by <a href="#BallArithmetic.rigorous_eigenvalues"><code>rigorous_eigenvalues</code></a> bundling the midpoint eigenvector factorisation, the certified eigenvalue enclosures, and the norm bounds underpinning their verification. Besides behaving like the underlying vector of eigenvalue balls, the struct exposes the interval residual, the projected residual used in the Miyajima certification, and the inverse defect (<code>inverse * vectors - I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/gev.jl#L48-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rigorous_eigenvalues"><a class="docstring-binding" href="#BallArithmetic.rigorous_eigenvalues"><code>BallArithmetic.rigorous_eigenvalues</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rigorous_eigenvalues(A::BallMatrix)</code></pre><p>Compute rigorous enclosures for the eigenvalues of <code>A</code>, following Ref. [<a href="../../references/#Miyajima2012">7</a>].  The returned <a href="#BallArithmetic.RigorousEigenvaluesResult"><code>RigorousEigenvaluesResult</code></a> exposes both the interval enclosures and the norm bounds used during certification.</p><p>TODO: Using Miyajima&#39;s algorithm is overkill, may be worth using</p><p><strong>References</strong></p><ul><li>[<a href="../../references/#Miyajima2012">7</a>] Miyajima, JCAM 246, 9 (2012)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/gev.jl#L153-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.evbox"><a class="docstring-binding" href="#BallArithmetic.evbox"><code>BallArithmetic.evbox</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evbox(A::BallMatrix{T})</code></pre><p>Backward-compatible wrapper returning only the vector of eigenvalue enclosures produced by <a href="#BallArithmetic.rigorous_eigenvalues"><code>rigorous_eigenvalues</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/gev.jl#L172-L177">source</a></section></details></article><h2 id="Rump-2022a-Method"><a class="docs-heading-anchor" href="#Rump-2022a-Method">Rump 2022a Method</a><a id="Rump-2022a-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Rump-2022a-Method" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.Rump2022aResult"><a class="docstring-binding" href="#BallArithmetic.Rump2022aResult"><code>BallArithmetic.Rump2022aResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rump2022aResult</code></pre><p>Container for Rump2022a eigenvalue and eigenvector error bounds.</p><p>Extends the standard eigenvalue result with:</p><ul><li>Individual eigenvector error bounds</li><li>Condition number estimates</li><li>Residual-based refinements</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/rump_2022a.jl#L8-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rump_2022a_eigenvalue_bounds"><a class="docstring-binding" href="#BallArithmetic.rump_2022a_eigenvalue_bounds"><code>BallArithmetic.rump_2022a_eigenvalue_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rump_2022a_eigenvalue_bounds(A::BallMatrix; method=:standard, hermitian=false)</code></pre><p>Compute verified error bounds for all eigenvalues and eigenvectors following Rump (2022a).</p><p>This method provides:</p><ol><li>Individual eigenvalue enclosures with guaranteed containment</li><li>Eigenvector error bounds for each eigenpair</li><li>Condition number estimates for stability assessment</li><li>Residual-based verification</li></ol><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Square matrix for eigenvalue problem</li><li><code>method::Symbol</code>: Verification method<ul><li><code>:standard</code> - Standard residual-based bounds (default)</li><li><code>:refined</code> - Refined bounds using Gershgorin + residuals</li><li><code>:krawczyk</code> - Krawczyk operator for sharper enclosures</li></ul></li><li><code>hermitian::Bool</code>: Whether A is Hermitian (enables tighter bounds)</li></ul><p><strong>Method Description</strong></p><p><strong>Standard method:</strong></p><p>For each eigenpair (λᵢ, vᵢ), computes:</p><ol><li>Residual: rᵢ = A<em>vᵢ - λᵢ</em>vᵢ</li><li>Eigenvalue bound: |λ̃ᵢ - λᵢ| ≤ ‖rᵢ‖/(1 - κᵢ*‖rᵢ‖)</li><li>Eigenvector bound: ‖ṽᵢ - vᵢ‖ ≤ κᵢ<em>‖rᵢ‖/(1 - κᵢ</em>‖rᵢ‖) where κᵢ is the condition number</li></ol><p><strong>Refined method:</strong></p><p>Combines Gershgorin discs with residual bounds for tighter enclosures, especially effective when eigenvalues are clustered.</p><p><strong>Krawczyk method:</strong></p><p>Uses interval Newton-Krawczyk operator for quadratic convergence in eigenvector refinement.</p><p><strong>Returns</strong></p><p><a href="#BallArithmetic.Rump2022aResult"><code>Rump2022aResult</code></a> containing verified bounds.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0; 1.0 2.0])
result = rump_2022a_eigenvalue_bounds(A; hermitian=true)

# Access results
λ = result.eigenvalues  # Eigenvalue balls
κ = result.condition_numbers  # Condition numbers
err = result.eigenvector_errors  # Eigenvector error bounds</code></pre><p><strong>Reference</strong></p><ul><li>Rump, S.M. (2022), &quot;Verified Error Bounds for All Eigenvalues and Eigenvectors of a Matrix&quot;, SIAM J. Matrix Anal. Appl. 43(4):1736–1754. DOI: 10.1137/21M1451440</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/rump_2022a.jl#L42-L97">source</a></section></details></article><h2 id="Rump-Lange-2023-Method"><a class="docs-heading-anchor" href="#Rump-Lange-2023-Method">Rump-Lange 2023 Method</a><a id="Rump-Lange-2023-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Rump-Lange-2023-Method" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.RumpLange2023Result"><a class="docstring-binding" href="#BallArithmetic.RumpLange2023Result"><code>BallArithmetic.RumpLange2023Result</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RumpLange2023Result</code></pre><p>Container for RumpLange2023 eigenvalue cluster bounds.</p><p>Emphasizes fast computation with clustering information:</p><ul><li>Cluster structure identification</li><li>Per-cluster error bounds</li><li>Fast bounds optimized for clustered spectra</li></ul><p><strong>Fields</strong></p><ul><li><code>eigenvectors::VT</code>: Approximate eigenvectors (as ball matrix)</li><li><code>eigenvalues::ΛT</code>: Certified eigenvalue enclosures</li><li><code>cluster_assignments::Vector{Int}</code>: Cluster assignments (cluster index for each eigenvalue)</li><li><code>cluster_bounds::Vector{Ball{T, T}}</code>: Cluster bounds (interval enclosure for each cluster)</li><li><code>num_clusters::Int</code>: Number of clusters identified</li><li><code>cluster_residuals::Vector{T}</code>: Per-cluster residual norms</li><li><code>cluster_separations::Vector{T}</code>: Per-cluster separation gaps</li><li><code>cluster_sizes::Vector{Int}</code>: Cluster sizes</li><li><code>verified::Bool</code>: Overall verification status</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/rump_lange_2023.jl#L8-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rump_lange_2023_cluster_bounds"><a class="docstring-binding" href="#BallArithmetic.rump_lange_2023_cluster_bounds"><code>BallArithmetic.rump_lange_2023_cluster_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rump_lange_2023_cluster_bounds(A::BallMatrix; hermitian=false, cluster_tol=1e-6, fast=true)</code></pre><p>Compute fast error bounds for eigenvalues with emphasis on cluster structure, following Rump &amp; Lange (2023).</p><p>This method excels when eigenvalues form clusters, providing:</p><ol><li>Fast identification of eigenvalue clusters</li><li>Tight bounds within each cluster</li><li>Optimized computation exploiting cluster structure</li><li>Scaling to large matrices via cluster-wise processing</li></ol><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Square matrix for eigenvalue problem</li><li><code>hermitian::Bool</code>: Whether A is Hermitian (enables faster algorithms)</li><li><code>cluster_tol::Real</code>: Tolerance for cluster identification (default: 1e-6)</li><li><code>fast::Bool</code>: Use fast approximations vs. rigorous bounds (default: true)</li></ul><p><strong>Method Description</strong></p><p><strong>Cluster identification:</strong></p><p>Uses Gershgorin discs with connectivity analysis to identify clusters of eigenvalues that are close together. Two eigenvalues belong to the same cluster if their Gershgorin discs overlap.</p><p><strong>Per-cluster bounds:</strong></p><p>For each cluster C<em>k with eigenvalues {λᵢ}ᵢ∈C</em>k:</p><ol><li>Compute cluster interval: [min λᵢ - δᵢ, max λᵢ + δᵢ]</li><li>Refine using projected residuals within cluster</li><li>Apply separation bounds between clusters</li></ol><p><strong>Fast mode:</strong></p><p>When <code>fast=true</code>, uses:</p><ul><li>Single power iteration for norms (vs. convergence)</li><li>Simplified residual bounds</li><li>Cluster-level (vs. individual) error propagation</li></ul><p>Results in ~10x speedup with typically &lt;2x looser bounds.</p><p><strong>Returns</strong></p><p><a href="#BallArithmetic.RumpLange2023Result"><code>RumpLange2023Result</code></a> containing cluster structure and bounds.</p><p><strong>Example</strong></p><p>Example usage for a matrix with two eigenvalue clusters:</p><ul><li>Create interval matrix with clustered spectrum</li><li>Call <code>rump_lange_2023_cluster_bounds(A; hermitian=true)</code></li><li>Result contains cluster assignments and per-cluster bounds</li></ul><p><strong>Performance Notes</strong></p><ul><li>For n×n matrix: O(n²) flops in fast mode, O(n³) in rigorous mode</li><li>Cluster count &lt;&lt; n gives significant speedup</li><li>Most effective when cluster separation &gt;&gt; cluster width</li></ul><p><strong>Reference</strong></p><ul><li>Rump, S.M. &amp; Lange, M. (2023), &quot;Fast Computation of Error Bounds...&quot;, SIAM J. Matrix Anal. Appl., to appear</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/rump_lange_2023.jl#L44-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.refine_cluster_bounds"><a class="docstring-binding" href="#BallArithmetic.refine_cluster_bounds"><code>BallArithmetic.refine_cluster_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">refine_cluster_bounds(result::RumpLange2023Result, A::BallMatrix; iterations=1)</code></pre><p>Refine cluster bounds using iterative residual computation.</p><p>Takes an existing <code>RumpLange2023Result</code> and performs additional refinement iterations to tighten the bounds, particularly for well-separated clusters.</p><p><strong>Arguments</strong></p><ul><li><code>result</code>: Initial cluster bound result</li><li><code>A</code>: Original ball matrix</li><li><code>iterations</code>: Number of refinement iterations (default: 1)</li></ul><p><strong>Returns</strong></p><p>New <code>RumpLange2023Result</code> with refined bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/rump_lange_2023.jl#L368-L383">source</a></section></details></article><h2 id="Generalized-Eigenvalues"><a class="docs-heading-anchor" href="#Generalized-Eigenvalues">Generalized Eigenvalues</a><a id="Generalized-Eigenvalues-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Eigenvalues" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.RigorousGeneralizedEigenvaluesResult"><a class="docstring-binding" href="#BallArithmetic.RigorousGeneralizedEigenvaluesResult"><code>BallArithmetic.RigorousGeneralizedEigenvaluesResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RigorousGeneralizedEigenvaluesResult</code></pre><p>Container returned by <a href="#BallArithmetic.rigorous_generalized_eigenvalues"><code>rigorous_generalized_eigenvalues</code></a> bundling the midpoint eigenvector factorisation, the certified eigenvalue enclosures, and the norm bounds underpinning their verification. Besides behaving like the underlying vector of eigenvalue balls, the struct exposes the interval residual, the projected residual used in the Miyajima certification, and the coupling defect of the left action (<code>left_action * B * right_vectors - I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/gev.jl#L4-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rigorous_generalized_eigenvalues"><a class="docstring-binding" href="#BallArithmetic.rigorous_generalized_eigenvalues"><code>BallArithmetic.rigorous_generalized_eigenvalues</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rigorous_generalized_eigenvalues(A::BallMatrix, B::BallMatrix)</code></pre><p>Compute rigorous enclosures for the eigenvalues of the generalised problem <code>A * x = λ * B * x</code>, following Ref. [<a href="../../references/#Miyajima2012">7</a>].  The returned <a href="#BallArithmetic.RigorousGeneralizedEigenvaluesResult"><code>RigorousGeneralizedEigenvaluesResult</code></a> exposes both the interval enclosures and the norm bounds used during certification.</p><p><strong>References</strong></p><ul><li>[<a href="../../references/#Miyajima2012">7</a>] Miyajima, JCAM 246, 9 (2012)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/gev.jl#L91-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.gevbox"><a class="docstring-binding" href="#BallArithmetic.gevbox"><code>BallArithmetic.gevbox</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gevbox(A::BallMatrix{T}, B::BallMatrix{T})</code></pre><p>Backward-compatible wrapper returning only the vector of eigenvalue enclosures produced by <a href="#BallArithmetic.rigorous_generalized_eigenvalues"><code>rigorous_generalized_eigenvalues</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/gev.jl#L108-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.GEVResult"><a class="docstring-binding" href="#BallArithmetic.GEVResult"><code>BallArithmetic.GEVResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GEVResult</code></pre><p>Result structure for verified generalized eigenvalue problem.</p><p>All numeric fields use Float64 precision. This struct is not currently parametric; extension to other numeric types would require making it GEVResult{T}.</p><p><strong>Fields</strong></p><ul><li><code>success::Bool</code>: Whether verification succeeded</li><li><code>eigenvalue_intervals::Vector{Tuple{Float64, Float64}}</code>: Verified intervals [λ̃ᵢ - ηᵢ, λ̃ᵢ + ηᵢ] for each eigenvalue</li><li><code>eigenvector_centers::Matrix{Float64}</code>: Approximate eigenvectors (centers)</li><li><code>eigenvector_radii::Vector{Float64}</code>: Verified radii ξᵢ for eigenvector balls</li><li><code>beta::Float64</code>: Preconditioning factor β ≥ √‖B⁻¹‖₂</li><li><code>global_bound::Float64</code>: Global eigenvalue bound δ̂ (Theorem 4)</li><li><code>individual_bounds::Vector{Float64}</code>: Individual eigenvalue bounds ε (Theorem 5)</li><li><code>separation_bounds::Vector{Float64}</code>: Separation bounds η (Lemma 2)</li><li><code>residual_norm::Float64</code>: Norm of residual matrix ‖Rg‖₂</li><li><code>message::String</code>: Diagnostic message (especially if success = false)</li></ul><p><strong>Interpretation</strong></p><ul><li>If <code>success = true</code>: All eigenvalue intervals are guaranteed to contain exactly one true eigenvalue, and all eigenvector balls contain the corresponding normalized eigenvector, rigorously accounting for all matrices in the input intervals [A] and [B].</li><li>If <code>success = false</code>: Check <code>message</code> for diagnostic information. Common failures:<ul><li>Approximate eigenvectors not sufficiently orthogonal (‖I - Gg‖₂ &gt;= 1)</li><li>Eigenvalues too clustered to separate</li><li>B not positive definite</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/verified_gev.jl#L15-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.verify_generalized_eigenpairs"><a class="docstring-binding" href="#BallArithmetic.verify_generalized_eigenpairs"><code>BallArithmetic.verify_generalized_eigenpairs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">verify_generalized_eigenpairs(A::BallMatrix, B::BallMatrix, X̃::Matrix, λ̃::Vector) -&gt; GEVResult</code></pre><p>Verify all eigenpairs of the generalized eigenvalue problem Ax = λBx.</p><p>Implements Algorithm 1 from Miyajima et al. (2010).</p><p><strong>Numeric Type Support</strong></p><p><strong>Currently supports Float64 only.</strong> All computations and error bounds are performed using Float64 arithmetic with IEEE 754 double precision. The implementation uses Float64-specific rounding error constants for rigorous verification.</p><p>Extension to BigFloat would require:</p><ul><li>Parametric GEVResult{T} struct</li><li>Type-dependent unit roundoff (eps(T))</li><li>Modified error analysis for arbitrary precision</li></ul><p>The mathematical algorithms (Theorems 4, 5, 7, 10) are precision-independent, but this implementation is optimized for Float64 hardware arithmetic.</p><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Symmetric interval matrix (n×n, Float64 elements)</li><li><code>B::BallMatrix</code>: Symmetric positive definite interval matrix (n×n, Float64 elements)</li><li><code>X̃::Matrix</code>: Approximate eigenvectors (n×n), typically from <code>eigen(A.c, B.c)</code></li><li><code>λ̃::Vector</code>: Approximate eigenvalues (n), assumed sorted</li></ul><p><strong>Returns</strong></p><ul><li><code>GEVResult</code> with verified eigenvalue intervals and eigenvector balls</li></ul><p><strong>Algorithm (4 steps)</strong></p><ol><li>Compute β ≥ √‖B⁻¹‖₂ using Theorem 10</li><li>Compute global bound δ̂ and individual bounds ε using Theorems 4, 5</li><li>Determine separation bounds η using Lemma 2</li><li>Compute eigenvector bounds ξ using Theorem 7</li></ol><p><strong>Complexity</strong></p><p>O(12n³) dominated by matrix multiplications with interval arithmetic</p><p><strong>Verification Guarantees</strong></p><p>When <code>success = true</code>:</p><ul><li>Each interval [λ̃ᵢ - ηᵢ, λ̃ᵢ + ηᵢ] contains exactly one true eigenvalue</li><li>Each ball B(x̃⁽ⁱ⁾, ξᵢ) contains the normalized true eigenvector</li><li>Results are rigorous for ALL matrices in the intervals [A] and [B]</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LinearAlgebra

A = BallMatrix([4.0 1.0; 1.0 3.0], fill(1e-10, 2, 2))
B = BallMatrix([2.0 0.5; 0.5 2.0], fill(1e-10, 2, 2))

F = eigen(Symmetric(A.c), Symmetric(B.c))
result = verify_generalized_eigenpairs(A, B, F.vectors, F.values)

if result.success
    println(&quot;Eigenvalue 1 ∈ &quot;, result.eigenvalue_intervals[1])
    println(&quot;Eigenvalue 2 ∈ &quot;, result.eigenvalue_intervals[2])
    println(&quot;Eigenvector radii: &quot;, result.eigenvector_radii)
end</code></pre><p><strong>References</strong></p><p>Miyajima, S., Ogita, T., Rump, S. M., Oishi, S. (2010). &quot;Fast Verification for All Eigenpairs in Symmetric Positive Definite Generalized Eigenvalue Problems&quot;. Reliable Computing 14, pp. 24-45.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/verified_gev.jl#L439-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_beta_bound"><a class="docstring-binding" href="#BallArithmetic.compute_beta_bound"><code>BallArithmetic.compute_beta_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_beta_bound(B::BallMatrix) -&gt; Float64</code></pre><p>Compute verified upper bound β ≥ √‖B⁻¹‖₂ using Theorem 10.</p><p>This function efficiently computes a bound on the square root of the 2-norm of B⁻¹ using Cholesky factorization and an approximate inverse.</p><p><strong>Numeric Type Support</strong></p><p><strong>Currently supports Float64 only.</strong> The error analysis uses Float64-specific rounding error constants (eps(Float64)). Extension to BigFloat would require:</p><ul><li>Type-parametric unit roundoff: eps(T) instead of eps(Float64)</li><li>Appropriate error analysis for higher precision</li><li>Parametric GEVResult struct</li></ul><p>The mathematical algorithm itself is not Float64-specific, but the rigorous error bounds in the implementation assume IEEE 754 double precision arithmetic.</p><p><strong>Arguments</strong></p><ul><li><code>B::BallMatrix</code>: Symmetric positive definite interval matrix (Float64 elements)</li></ul><p><strong>Returns</strong></p><ul><li><code>β::Float64</code>: Upper bound on √‖B⁻¹‖₂</li></ul><p><strong>Algorithm (Theorem 10)</strong></p><ol><li>Compute Cholesky factorization B ≈ LL^T</li><li>Compute approximate inverse X_L ≈ L⁻¹</li><li>Use interval arithmetic to bound error</li><li>Return β = √((α₁α∞)/(1 - α₁α∞αC))</li></ol><p><strong>Complexity</strong></p><p>O(n³) for Cholesky and inverse</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">B = BallMatrix([2.0 0.5; 0.5 2.0], fill(1e-10, 2, 2))
β = compute_beta_bound(B)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/verified_gev.jl#L59-L97">source</a></section></details></article><h2 id="Singular-Value-Decomposition"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition">Singular Value Decomposition</a><a id="Singular-Value-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.RigorousSVDResult"><a class="docstring-binding" href="#BallArithmetic.RigorousSVDResult"><code>BallArithmetic.RigorousSVDResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RigorousSVDResult</code></pre><p>Container returned by <a href="#BallArithmetic.rigorous_svd"><code>rigorous_svd</code></a> bundling the midpoint factorisation, the certified singular-value enclosures, and the block-diagonal refinement obtained from <a href="#BallArithmetic.miyajima_vbd"><code>miyajima_vbd</code></a>.  Besides the singular values themselves the struct exposes the residual and orthogonality defect bounds that underpin the certification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/svd.jl#L43-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rigorous_svd"><a class="docstring-binding" href="#BallArithmetic.rigorous_svd"><code>BallArithmetic.rigorous_svd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rigorous_svd(A::BallMatrix; apply_vbd = true)</code></pre><p>Compute a rigorous singular value decomposition of the ball matrix <code>A</code>. The midpoint SVD is certified following Theorem 3.1 of Ref. [<a href="../../references/#Rump2011">10</a>]; optionally, the resulting singular-value enclosure can be refined by applying <a href="#BallArithmetic.miyajima_vbd"><code>miyajima_vbd</code></a> to <code>Σ&#39;Σ</code>, yielding a block-diagonal structure with a rigorously bounded remainder.</p><p>The returned <a href="#BallArithmetic.RigorousSVDResult"><code>RigorousSVDResult</code></a> exposes both the enclosures and the intermediate norm bounds that justify them. When <code>apply_vbd</code> is set to <code>false</code>, the <code>block_diagonalisation</code> field is <code>nothing</code>.</p><p><strong>References</strong></p><ul><li>Miyajima S. (2014), &quot;Verified bounds for all the singular values of matrix&quot;, Japan J. Indust. Appl. Math. 31, 513–539.</li><li>Rump S.M. (2011), &quot;Verified bounds for singular values&quot;, BIT 51, 367–384.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/svd.jl#L129-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.svdbox"><a class="docstring-binding" href="#BallArithmetic.svdbox"><code>BallArithmetic.svdbox</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svdbox(A::BallMatrix; method = MiyajimaM1(), apply_vbd = true)</code></pre><p>Backward-compatible wrapper returning only the vector of singular-value enclosures produced by <a href="#BallArithmetic.rigorous_svd"><code>rigorous_svd</code></a>.  New code should prefer <a href="#BallArithmetic.rigorous_svd"><code>rigorous_svd</code></a> directly to access the additional certification data.  The optional <code>method</code> and <code>apply_vbd</code> flags mirror those in <a href="#BallArithmetic.rigorous_svd"><code>rigorous_svd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/svd.jl#L202-L210">source</a></section></details></article><h2 id="Miyajima-VBD"><a class="docs-heading-anchor" href="#Miyajima-VBD">Miyajima VBD</a><a id="Miyajima-VBD-1"></a><a class="docs-heading-anchor-permalink" href="#Miyajima-VBD" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.MiyajimaVBDResult"><a class="docstring-binding" href="#BallArithmetic.MiyajimaVBDResult"><code>BallArithmetic.MiyajimaVBDResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MiyajimaVBDResult</code></pre><p>Container returned by <a href="#BallArithmetic.miyajima_vbd"><code>miyajima_vbd</code></a> encapsulating the data produced by the verified block diagonalisation (VBD) step. The fields contain the basis that block diagonalises the midpoint matrix, the transformed enclosure, its block-diagonal truncation, the rigorous remainder, and the Gershgorin clusters that certify how the spectrum groups together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/miyajima_vbd.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.miyajima_vbd"><a class="docstring-binding" href="#BallArithmetic.miyajima_vbd"><code>BallArithmetic.miyajima_vbd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">miyajima_vbd(A::BallMatrix; hermitian = false)</code></pre><p>Perform Miyajima&#39;s verified block diagonalisation (VBD) on the square ball matrix <code>A</code>.  The midpoint matrix is reduced either by an eigenvalue decomposition (when <code>hermitian = true</code>) or by a unitary Schur form (for the general case).  The enclosure is transported to that basis, the Gershgorin discs are clustered, and a block-diagonal truncation together with a rigorous remainder is produced.</p><p>Overlapping discs are grouped via their connectivity graph so that each cluster becomes contiguous after a basis permutation.  The remainder bound combines the classical Collatz estimate with a block-separation bound that exploits the verified gaps between clusters.</p><p>When <code>hermitian = true</code> the routine expects <code>A</code> to be Hermitian and the resulting eigenvalues and intervals are real.  Otherwise the Schur form is used and the clusters are discs in the complex plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/miyajima_vbd.jl#L30-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.refine_svd_bounds_with_vbd"><a class="docstring-binding" href="#BallArithmetic.refine_svd_bounds_with_vbd"><code>BallArithmetic.refine_svd_bounds_with_vbd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">refine_svd_bounds_with_vbd(result::RigorousSVDResult)</code></pre><p>Attempt to refine singular value bounds using VBD isolation information.</p><p>For singular values whose squared values fall in isolated Gershgorin clusters, we can potentially tighten the bounds using Miyajima&#39;s Theorem 11.</p><p>Returns a new <code>RigorousSVDResult</code> with potentially tighter bounds, or the original result if no refinement is possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/svd.jl#L566-L576">source</a></section></details></article><h2 id="Adaptive-Ogita-SVD"><a class="docs-heading-anchor" href="#Adaptive-Ogita-SVD">Adaptive Ogita SVD</a><a id="Adaptive-Ogita-SVD-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Ogita-SVD" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.OgitaSVDRefinementResult"><a class="docstring-binding" href="#BallArithmetic.OgitaSVDRefinementResult"><code>BallArithmetic.OgitaSVDRefinementResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OgitaSVDRefinementResult</code></pre><p>Result from Ogita&#39;s iterative SVD refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/adaptive_ogita_svd.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.AdaptiveSVDResult"><a class="docstring-binding" href="#BallArithmetic.AdaptiveSVDResult"><code>BallArithmetic.AdaptiveSVDResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AdaptiveSVDResult</code></pre><p>Result from adaptive precision SVD computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/adaptive_ogita_svd.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.ogita_svd_refine"><a class="docstring-binding" href="#BallArithmetic.ogita_svd_refine"><code>BallArithmetic.ogita_svd_refine</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ogita_svd_refine(A::AbstractMatrix{T}, U, Σ, V;
                 max_iterations=10, precision_bits=256,
                 check_convergence=false,
                 use_optimal_iterations=false) where {T&lt;:AbstractFloat}</code></pre><p>Refine an approximate SVD using Ogita&#39;s iterative method (RefSVD algorithm).</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Original matrix (in higher precision if needed)</li><li><code>U</code>: Initial left singular vectors</li><li><code>Σ</code>: Initial singular values</li><li><code>V</code>: Initial right singular vectors</li><li><code>max_iterations</code>: Maximum number of iterations to run (default: 10)</li><li><code>precision_bits</code>: Working precision in bits (default: 256)</li><li><code>check_convergence</code>: If <code>true</code>, check convergence via spectral norm and stop early.                      If <code>false</code> (default), run fixed number of iterations.</li><li><code>use_optimal_iterations</code>: If <code>true</code>, compute optimal iteration count from quadratic                           convergence theory and ignore max_iterations.                           This is the fastest option for known target precision.</li></ul><p><strong>Iteration count (quadratic convergence from Float64)</strong></p><p>Based on theory, starting from Float64 (~53 bits), each iteration doubles precision:</p><ul><li>3 iterations: sufficient for 256-bit (~77 decimal digits)</li><li>4 iterations: sufficient for 512-bit (~154 decimal digits)</li><li>5 iterations: sufficient for 1024-bit (~308 decimal digits)</li></ul><p><strong>Returns</strong></p><ul><li><code>OgitaSVDRefinementResult</code> containing refined SVD</li></ul><p><strong>References</strong></p><ul><li>[<a href="../../references/#OgitaAishima2020">6</a>] Ogita, T. &amp; Aishima, K. (2020), &quot;Iterative refinement for singular value decomposition based on matrix multiplication&quot;, J. Comput. Appl. Math. 369, 112512.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/adaptive_ogita_svd.jl#L94-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.adaptive_ogita_svd"><a class="docstring-binding" href="#BallArithmetic.adaptive_ogita_svd"><code>BallArithmetic.adaptive_ogita_svd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">adaptive_ogita_svd(A::BallMatrix{T};
                   tolerance=1e-10,
                   method::SVDMethod=MiyajimaM1(),
                   apply_vbd=true,
                   max_precision_bits=1024,
                   max_refinement_iterations=5) where {T}</code></pre><p>Compute rigorous SVD bounds with adaptive precision using Ogita&#39;s refinement.</p><p><strong>Algorithm</strong></p><ol><li>Start with Float64 precision</li><li>Compute rigorous SVD bounds using <code>rigorous_svd</code></li><li>Check if max(rad(σᵢ)) &lt; tolerance</li><li>If not satisfied, refine using Ogita&#39;s method with doubled precision</li><li>Repeat until tolerance met or max precision reached</li></ol><p><strong>Arguments</strong></p><ul><li><code>A</code>: Input ball matrix</li><li><code>tolerance</code>: Target tolerance for max(rad(σᵢ))</li><li><code>method</code>: SVD certification method (MiyajimaM1, MiyajimaM4, RumpOriginal)</li><li><code>apply_vbd</code>: Whether to apply verified block diagonalization</li><li><code>max_precision_bits</code>: Maximum precision to use (bits)</li><li><code>max_refinement_iterations</code>: Maximum number of refinement steps</li></ul><p><strong>Returns</strong></p><ul><li><code>AdaptiveSVDResult</code> containing final rigorous result and adaptation history</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(1e-8, 2, 2))
result = adaptive_ogita_svd(A; tolerance=1e-12)

# Access final result
σ = result.rigorous_result.singular_values
println(&quot;Final precision: &quot;, result.final_precision, &quot; bits&quot;)
println(&quot;Max radius: &quot;, maximum(rad.(σ)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/adaptive_ogita_svd.jl#L336-L374">source</a></section></details></article><h2 id="SVD-Caching"><a class="docs-heading-anchor" href="#SVD-Caching">SVD Caching</a><a id="SVD-Caching-1"></a><a class="docs-heading-anchor-permalink" href="#SVD-Caching" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.clear_svd_cache!"><a class="docstring-binding" href="#BallArithmetic.clear_svd_cache!"><code>BallArithmetic.clear_svd_cache!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_svd_cache!()</code></pre><p>Clear the BigFloat SVD cache used for warm-starting Ogita refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/svd.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.svd_cache_stats"><a class="docstring-binding" href="#BallArithmetic.svd_cache_stats"><code>BallArithmetic.svd_cache_stats</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">svd_cache_stats()</code></pre><p>Return statistics about the BigFloat SVD cache usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/svd.jl#L106-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.set_svd_cache!"><a class="docstring-binding" href="#BallArithmetic.set_svd_cache!"><code>BallArithmetic.set_svd_cache!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_svd_cache!(U, S, V, A_hash)</code></pre><p>Set the SVD cache with the given factors and matrix hash. Used for warm-starting Ogita refinement on nearby matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/svd.jl#L115-L120">source</a></section></details></article><h2 id="Spectral-Projectors"><a class="docs-heading-anchor" href="#Spectral-Projectors">Spectral Projectors</a><a id="Spectral-Projectors-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-Projectors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.RigorousSpectralProjectorsResult"><a class="docstring-binding" href="#BallArithmetic.RigorousSpectralProjectorsResult"><code>BallArithmetic.RigorousSpectralProjectorsResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RigorousSpectralProjectorsResult</code></pre><p>Container returned by <a href="#BallArithmetic.miyajima_spectral_projectors"><code>miyajima_spectral_projectors</code></a> encapsulating the rigorously computed spectral projectors for each eigenvalue cluster identified by verified block diagonalization (VBD).</p><p>Each projector <code>P_k</code> is a ball matrix satisfying:</p><ul><li><code>P_k^2 ≈ P_k</code> (idempotency)</li><li><code>∑_k P_k ≈ I</code> (resolution of identity)</li><li><code>P_i * P_j ≈ 0</code> for <code>i ≠ j</code> (orthogonality)</li><li><code>A * P_k ≈ P_k * A * P_k</code> (invariance)</li></ul><p>The projectors are constructed from the basis that block-diagonalizes the matrix, restricted to each spectral cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projectors.jl#L6-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.miyajima_spectral_projectors"><a class="docstring-binding" href="#BallArithmetic.miyajima_spectral_projectors"><code>BallArithmetic.miyajima_spectral_projectors</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">miyajima_spectral_projectors(A::BallMatrix; hermitian=false, verify_invariance=true)</code></pre><p>Compute rigorous enclosures for spectral projectors corresponding to each eigenvalue cluster identified by Miyajima&#39;s verified block diagonalization (VBD).</p><p>The method follows the approach from Ref. [<a href="../../references/#MiyajimaInvariantSubspaces2014">8</a>]:</p><ol><li>Apply VBD to obtain basis <code>V</code> that block-diagonalizes <code>A</code></li><li>For each cluster <code>k</code>, extract columns <code>V[:, cluster_k]</code></li><li>Construct projector <code>P_k = V[:, cluster_k] * V[:, cluster_k]&#39;</code> as ball matrix</li><li>Verify idempotency, orthogonality, and resolution of identity</li></ol><p>When <code>hermitian = true</code>, the basis is computed via eigendecomposition and projectors are Hermitian. Otherwise, the Schur basis is used.</p><p>When <code>verify_invariance = true</code>, additionally verifies that <code>A * P_k ≈ P_k * A * P_k</code> for each projector, confirming that the columns of <code>P_k</code> span an invariant subspace.</p><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Square ball matrix whose spectral projectors to compute</li><li><code>hermitian::Bool = false</code>: Whether to assume <code>A</code> is Hermitian</li><li><code>verify_invariance::Bool = true</code>: Whether to verify invariant subspace property</li></ul><p><strong>Returns</strong></p><p><a href="#BallArithmetic.RigorousSpectralProjectorsResult"><code>RigorousSpectralProjectorsResult</code></a> containing the projectors and verification data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using BallArithmetic, LinearAlgebra

# Create a matrix with clustered eigenvalues
A = BallMatrix(Diagonal([1.0, 1.1, 5.0, 5.1]))

# Compute projectors
result = miyajima_spectral_projectors(A; hermitian=true)

# Access projectors
P1 = result[1]  # Projector for first cluster (eigenvalues ≈ 1.0, 1.1)
P2 = result[2]  # Projector for second cluster (eigenvalues ≈ 5.0, 5.1)

# Verify properties
@assert result.idempotency_defect &lt; 1e-10
@assert result.orthogonality_defect &lt; 1e-10</code></pre><p><strong>References</strong></p><ul><li>[<a href="../../references/#MiyajimaInvariantSubspaces2014">8</a>] Miyajima, SIAM J. Matrix Anal. Appl. 35, 1205–1225 (2014)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projectors.jl#L48-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_invariant_subspace_basis"><a class="docstring-binding" href="#BallArithmetic.compute_invariant_subspace_basis"><code>BallArithmetic.compute_invariant_subspace_basis</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_invariant_subspace_basis(proj_result::RigorousSpectralProjectorsResult, k::Int)</code></pre><p>Extract an orthonormal basis for the invariant subspace corresponding to cluster <code>k</code> from the spectral projector result.</p><p>Returns a <code>BallMatrix</code> whose columns span the invariant subspace associated with the k-th eigenvalue cluster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projectors.jl#L200-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.verify_projector_properties"><a class="docstring-binding" href="#BallArithmetic.verify_projector_properties"><code>BallArithmetic.verify_projector_properties</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">verify_projector_properties(proj_result::RigorousSpectralProjectorsResult; tol=1e-10)</code></pre><p>Verify that all projector properties hold within the specified tolerance. Returns <code>true</code> if all properties are satisfied, <code>false</code> otherwise.</p><p>Checks:</p><ol><li>Idempotency: ‖P<em>k^2 - P</em>k‖₂ &lt; tol for all k</li><li>Orthogonality: ‖P<em>i * P</em>j‖₂ &lt; tol for all i ≠ j</li><li>Resolution: ‖∑<em>k P</em>k - I‖₂ &lt; tol</li><li>Invariance: ‖A<em>P<em>k - P</em>k</em>A*P_k‖₂ &lt; tol for all k (if computed)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projectors.jl#L215-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.projector_condition_number"><a class="docstring-binding" href="#BallArithmetic.projector_condition_number"><code>BallArithmetic.projector_condition_number</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">projector_condition_number(proj_result::RigorousSpectralProjectorsResult, k::Int)</code></pre><p>Estimate the condition number of the k-th spectral projector based on the gap between eigenvalue clusters.</p><p>A small gap indicates potential ill-conditioning of the projector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projectors.jl#L243-L250">source</a></section></details></article><h2 id="Block-Schur-Decomposition"><a class="docs-heading-anchor" href="#Block-Schur-Decomposition">Block Schur Decomposition</a><a id="Block-Schur-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Schur-Decomposition" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.RigorousBlockSchurResult"><a class="docstring-binding" href="#BallArithmetic.RigorousBlockSchurResult"><code>BallArithmetic.RigorousBlockSchurResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RigorousBlockSchurResult</code></pre><p>Container returned by <a href="#BallArithmetic.rigorous_block_schur"><code>rigorous_block_schur</code></a> encapsulating a verified block Schur decomposition <code>A ≈ Q * T * Q&#39;</code> where:</p><ul><li><code>Q</code> is an approximately orthogonal/unitary transformation (as ball matrix)</li><li><code>T</code> is in block upper quasi-triangular form</li><li>Diagonal blocks correspond to eigenvalue clusters</li><li>Off-diagonal blocks are rigorously bounded</li></ul><p>The decomposition satisfies:</p><ul><li><code>A ≈ Q * T * Q&#39;</code> with rigorous residual bounds</li><li><code>Q&#39; * Q ≈ I</code> with rigorous orthogonality defect bounds</li><li>Each diagonal block <code>T[cluster_k, cluster_k]</code> contains eigenvalues from cluster k</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/block_schur.jl#L4-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rigorous_block_schur"><a class="docstring-binding" href="#BallArithmetic.rigorous_block_schur"><code>BallArithmetic.rigorous_block_schur</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rigorous_block_schur(A::BallMatrix; hermitian=false, block_structure=:quasi_triangular)</code></pre><p>Compute a rigorous block Schur decomposition <code>A ≈ Q * T * Q&#39;</code> where <code>Q</code> is orthogonal/unitary and <code>T</code> is in block form determined by eigenvalue clustering.</p><p>The method follows Miyajima&#39;s VBD framework:</p><ol><li>Apply verified block diagonalization to identify eigenvalue clusters</li><li>Construct orthogonal basis <code>Q</code> from the diagonalizing transformation</li><li>Transform matrix to block form <code>T = Q&#39; * A * Q</code></li><li>Verify orthogonality of <code>Q</code> and residual bounds</li></ol><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Square ball matrix to decompose</li><li><code>hermitian::Bool = false</code>: Whether to assume <code>A</code> is Hermitian</li><li><code>block_structure::Symbol = :quasi_triangular</code>: Block structure to compute<ul><li><code>:diagonal</code>: Keep only diagonal blocks (same as VBD)</li><li><code>:quasi_triangular</code>: Keep upper triangular block structure</li><li><code>:full</code>: Keep all blocks (no truncation)</li></ul></li></ul><p><strong>Returns</strong></p><p><a href="#BallArithmetic.RigorousBlockSchurResult"><code>RigorousBlockSchurResult</code></a> containing the decomposition and verification data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using BallArithmetic, LinearAlgebra

# Create a matrix with clustered eigenvalues
A = BallMatrix([2.0 0.1 0.05 0.02;
                0.1 2.1 0.03 0.01;
                0.05 0.03 5.0 0.15;
                0.02 0.01 0.15 5.1])

# Compute block Schur form
result = rigorous_block_schur(A; hermitian=true)

# Access components
Q = result.Q
T = result.T

# Verify decomposition
@assert result.residual_norm &lt; 1e-10
@assert result.orthogonality_defect &lt; 1e-10</code></pre><p><strong>References</strong></p><ul><li>[<a href="../../references/#MiyajimaInvariantSubspaces2014">8</a>] Miyajima, SIAM J. Matrix Anal. Appl. 35, 1205–1225 (2014)</li><li>[<a href="../../references/#Miyajima2014">11</a>] Miyajima, Japan J. Indust. Appl. Math. 31, 513–539 (2014)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/block_schur.jl#L46-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.extract_cluster_block"><a class="docstring-binding" href="#BallArithmetic.extract_cluster_block"><code>BallArithmetic.extract_cluster_block</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_cluster_block(result::RigorousBlockSchurResult, i::Int, j::Int)</code></pre><p>Extract the (i,j)-th block from the block Schur form <code>T</code>. Returns a <code>BallMatrix</code> corresponding to <code>T[cluster_i, cluster_j]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/block_schur.jl#L216-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.verify_block_schur_properties"><a class="docstring-binding" href="#BallArithmetic.verify_block_schur_properties"><code>BallArithmetic.verify_block_schur_properties</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">verify_block_schur_properties(result::RigorousBlockSchurResult; tol=1e-10)</code></pre><p>Verify that the block Schur decomposition satisfies all required properties within the specified tolerance.</p><p>Checks:</p><ol><li>Residual: ‖A - Q<em>T</em>Q&#39;‖₂ &lt; tol</li><li>Orthogonality: ‖Q&#39;*Q - I‖₂ &lt; tol</li><li>Block structure preserved (if applicable)</li></ol><p>Returns <code>true</code> if all properties are satisfied, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/block_schur.jl#L232-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.estimate_block_separation"><a class="docstring-binding" href="#BallArithmetic.estimate_block_separation"><code>BallArithmetic.estimate_block_separation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_block_separation(result::RigorousBlockSchurResult, i::Int, j::Int)</code></pre><p>Estimate the spectral separation between clusters i and j. A small separation indicates potential numerical difficulties in separating the corresponding invariant subspaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/block_schur.jl#L273-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.refine_off_diagonal_block"><a class="docstring-binding" href="#BallArithmetic.refine_off_diagonal_block"><code>BallArithmetic.refine_off_diagonal_block</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">refine_off_diagonal_block(result::RigorousBlockSchurResult, i::Int, j::Int)</code></pre><p>Refine the (i,j) off-diagonal block by solving the block Sylvester equation with Miyajima&#39;s verified solver.</p><p>For i &lt; j, solves <code>T_ii&#39; * Y - Y * T_jj&#39; = T_ij&#39;</code> to obtain a refined enclosure for the (i,j) off-diagonal block.</p><p>Returns a <code>BallMatrix</code> with rigorous enclosure for the refined block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/block_schur.jl#L284-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_block_sylvester_rhs"><a class="docstring-binding" href="#BallArithmetic.compute_block_sylvester_rhs"><code>BallArithmetic.compute_block_sylvester_rhs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_block_sylvester_rhs(result::RigorousBlockSchurResult, i::Int, j::Int)</code></pre><p>For clusters i &lt; j, compute the right-hand side for the block Sylvester equation that would refine the (i,j) off-diagonal block.</p><p>Given <code>T_ii * X + X * T_jj = C</code>, returns the matrix <code>C</code> that should equal <code>T[cluster_i, cluster_j]</code> if the block Schur form were exact.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/block_schur.jl#L255-L263">source</a></section></details></article><h2 id="Schur-Spectral-Projectors"><a class="docs-heading-anchor" href="#Schur-Spectral-Projectors">Schur Spectral Projectors</a><a id="Schur-Spectral-Projectors-1"></a><a class="docs-heading-anchor-permalink" href="#Schur-Spectral-Projectors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.SchurSpectralProjectorResult"><a class="docstring-binding" href="#BallArithmetic.SchurSpectralProjectorResult"><code>BallArithmetic.SchurSpectralProjectorResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SchurSpectralProjectorResult{T}</code></pre><p>Result of verified spectral projector computation from Schur decomposition.</p><p><strong>Fields</strong></p><ul><li><code>projector::BallMatrix{T}</code>: Rigorous enclosure of the spectral projector P</li><li><code>schur_projector::BallMatrix{T}</code>: Projector in Schur coordinates</li><li><code>coupling_matrix::BallMatrix{T}</code>: Solution Y to the Sylvester equation T₁₁Y - YT₂₂ = T₁₂</li><li><code>eigenvalue_separation::T</code>: Lower bound on min|λᵢ - λⱼ| for i ∈ S, j ∉ S</li><li><code>projector_norm::T</code>: Upper bound on ‖P‖₂</li><li><code>idempotency_defect::T</code>: Upper bound on ‖P² - P‖₂</li><li><code>schur_basis::Matrix{T}</code>: Unitary matrix Q from A = QTQ^†</li><li><code>schur_form::Matrix{T}</code>: Upper triangular T from A = QTQ^†</li><li><code>cluster_indices::UnitRange{Int}</code>: Indices in Schur form corresponding to projected eigenvalues</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projection_schur.jl#L4-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_spectral_projector_schur"><a class="docstring-binding" href="#BallArithmetic.compute_spectral_projector_schur"><code>BallArithmetic.compute_spectral_projector_schur</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_spectral_projector_schur(A::BallMatrix, cluster_indices::UnitRange{Int};
                                 verify_idempotency::Bool=true)</code></pre><p>Compute rigorous enclosure of the spectral projector for eigenvalues at specified Schur form indices using verified Sylvester equation solver.</p><p><strong>Mathematical Background</strong></p><p>Given a matrix A with Schur decomposition A = QTQ^†, where T is upper triangular, partition T into blocks:</p><pre><code class="language-julia hljs">T = [T₁₁  T₁₂]
    [0    T₂₂]</code></pre><p>where T₁₁ contains the eigenvalues we want to project onto (diagonal entries at positions given by <code>cluster_indices</code>).</p><p>The spectral projector (Riesz projector) onto the eigenspace corresponding to eigenvalues of T₁₁ is:</p><pre><code class="language-julia hljs">P = Q * P_Schur * Q^†</code></pre><p>where P_Schur is the projector in Schur coordinates:</p><pre><code class="language-julia hljs">P_Schur = [I   Y]
          [0   0]</code></pre><p>and Y solves the Sylvester equation:</p><pre><code class="language-julia hljs">T₁₁*Y - Y*T₂₂ = T₁₂</code></pre><p>This is solved rigorously using <a href="../linearsystems/#BallArithmetic.triangular_sylvester_miyajima_enclosure"><code>triangular_sylvester_miyajima_enclosure</code></a>.</p><p><strong>Algorithm</strong></p><ol><li>Compute Schur decomposition: A = QTQ^† (using approximate Schur for A.c)</li><li>Extract blocks T₁₁, T₁₂, T₂₂ based on cluster_indices</li><li>Solve Sylvester equation rigorously: T₁₁<em>Y - Y</em>T₂₂ = T₁₂</li><li>Construct P_Schur = [I Y; 0 0] with interval arithmetic</li><li>Transform back: P = Q * P_Schur * Q^† with interval arithmetic</li><li>Verify idempotency: ‖P² - P‖₂ &lt; tol</li></ol><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Square interval matrix (n × n)</li><li><code>cluster_indices::UnitRange{Int}</code>: Indices of eigenvalues to project onto (corresponds to positions in Schur form, typically 1:k for first k eigenvalues)</li><li><code>verify_idempotency::Bool=true</code>: Check that ‖P² - P‖₂ is small</li></ul><p><strong>Returns</strong></p><p><a href="#BallArithmetic.SchurSpectralProjectorResult"><code>SchurSpectralProjectorResult</code></a> containing the verified projector and diagnostics.</p><p><strong>Examples</strong></p><p><strong>Project onto first two eigenvalues</strong></p><pre><code class="language-julia hljs">using BallArithmetic, LinearAlgebra

# Matrix with small uncertainties
A = BallMatrix([1.0 2.0 0.0; 0.0 3.0 1.0; 0.0 0.0 5.0], fill(1e-10, 3, 3))

# Compute projector onto eigenvalues 1.0 and 3.0 (first two in Schur form)
result = compute_spectral_projector_schur(A, 1:2)

P = result.projector
@show result.eigenvalue_separation  # Gap to third eigenvalue
@show result.idempotency_defect     # ‖P² - P‖₂

# Project a vector
v = BallVector([1.0, 2.0, 3.0])
v_projected = P * v</code></pre><p><strong>For a clustered matrix</strong></p><pre><code class="language-julia hljs"># Upper triangular matrix with eigenvalues [1.0, 1.1, 5.0, 5.1]
A = BallMatrix(triu(randn(4,4)) .+ Diagonal([1.0, 1.1, 5.0, 5.1]))

# After sorting eigenvalues by Schur decomposition, project onto first cluster
result = compute_spectral_projector_schur(A, 1:2)</code></pre><p><strong>Notes</strong></p><ul><li>Requires non-zero eigenvalue separation: min|λᵢ - λⱼ| for i ∈ cluster, j ∉ cluster</li><li>The Sylvester equation solver may fail if separation is too small</li><li>Complexity: O(n³) for Schur decomposition + O(k²(n-k)²) for Sylvester solver</li><li>For hermitian matrices, use <code>compute_spectral_projector_hermitian</code> instead (more efficient)</li><li>The projector P satisfies: P² ≈ P and P<em>A ≈ A</em>P (modulo idempotency defect)</li><li><strong>Caveat</strong>: The Schur decomposition of the midpoint matrix is not itself rigorously enclosed (Q and T carry zero radii). The Sylvester coupling Y is rigorously bounded, but the final projector P = Q·P<em>Schur·Q† does not account for the Schur approximation error. The idempotency and invariance checks verify self-consistency of the result, but do not guarantee that the true spectral projector lies within the computed ball. For a fully rigorous enclosure, use [`miyajima</em>spectral_projectors`](@ref) instead.</li></ul><p><strong>References</strong></p><ul><li>Kato, T. &quot;Perturbation Theory for Linear Operators&quot; (1995), Chapter II.4</li><li>Stewart, G. W., Sun, J. &quot;Matrix Perturbation Theory&quot; (1990), Chapter V</li><li>Miyajima, S. &quot;Fast enclosure for all eigenvalues in generalized eigenvalue problems&quot; SIAM J. Matrix Anal. Appl. 35, 1205–1225 (2014)</li></ul><p><strong>See Also</strong></p><ul><li><a href="../linearsystems/#BallArithmetic.triangular_sylvester_miyajima_enclosure"><code>triangular_sylvester_miyajima_enclosure</code></a>: Verified Sylvester solver used internally</li><li><a href="#BallArithmetic.project_vector_spectral"><code>project_vector_spectral</code></a>: Convenient interface to project vectors using this result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projection_schur.jl#L33-L145">source</a></section><section><div><pre><code class="language-julia hljs">compute_spectral_projector_schur(A::BallMatrix, target_indices::AbstractVector{Int};
                                 verify_idempotency::Bool=true,
                                 schur_data=nothing)</code></pre><p>Compute rigorous spectral projector for eigenvalues at arbitrary Schur form positions.</p><p>Unlike the <code>UnitRange</code> method, this accepts any subset of eigenvalue indices. Internally, the Schur form is reordered (via <code>ordschur</code>) so the target eigenvalues occupy positions <code>1:k</code>, then the standard Sylvester-based projector pipeline is applied.</p><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Square interval matrix (n × n)</li><li><code>target_indices::AbstractVector{Int}</code>: Positions of eigenvalues in Schur form to project onto</li><li><code>verify_idempotency::Bool=true</code>: Check ‖P² - P‖₂</li><li><code>schur_data=nothing</code>: Optional pre-computed <code>(Q, T)</code> Schur factors to skip internal Schur</li></ul><p><strong>Returns</strong></p><p><a href="#BallArithmetic.SchurSpectralProjectorResult"><code>SchurSpectralProjectorResult</code></a> with the reordered Schur factors and verified projector.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix(randn(5, 5))
# Project onto 2nd and 4th eigenvalues (arbitrary positions)
result = compute_spectral_projector_schur(A, [2, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projection_schur.jl#L194-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_spectral_projector_hermitian"><a class="docstring-binding" href="#BallArithmetic.compute_spectral_projector_hermitian"><code>BallArithmetic.compute_spectral_projector_hermitian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_spectral_projector_hermitian(A::BallMatrix, cluster_indices::UnitRange{Int})</code></pre><p>Compute spectral projector for Hermitian matrix (simplified, no Sylvester equation needed).</p><p>For Hermitian matrices, eigenvectors are orthogonal, so the spectral projector is simply:</p><pre><code class="language-julia hljs">P = V_S * V_S^†</code></pre><p>where V_S are the eigenvectors corresponding to the selected eigenvalues.</p><p>This is more efficient than the general Schur-based method since no Sylvester equation needs to be solved.</p><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Hermitian interval matrix</li><li><code>cluster_indices::UnitRange{Int}</code>: Indices of eigenvalues to project onto (after sorting)</li></ul><p><strong>Returns</strong></p><p><a href="#BallArithmetic.SchurSpectralProjectorResult"><code>SchurSpectralProjectorResult</code></a> with the verified projector.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Symmetric matrix
A = BallMatrix([4.0 1.0; 1.0 3.0], fill(1e-10, 2, 2))

# Project onto first eigenvalue
result = compute_spectral_projector_hermitian(A, 1:1)
P = result.projector</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projection_schur.jl#L333-L363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.project_vector_spectral"><a class="docstring-binding" href="#BallArithmetic.project_vector_spectral"><code>BallArithmetic.project_vector_spectral</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_vector_spectral(v::BallVector, result::SchurSpectralProjectorResult)</code></pre><p>Project interval vector onto eigenspace using precomputed spectral projector.</p><p><strong>Arguments</strong></p><ul><li><code>v::BallVector</code>: Interval vector to project</li><li><code>result::SchurSpectralProjectorResult</code>: Precomputed projector from <a href="#BallArithmetic.compute_spectral_projector_schur"><code>compute_spectral_projector_schur</code></a> or <a href="#BallArithmetic.compute_spectral_projector_hermitian"><code>compute_spectral_projector_hermitian</code></a></li></ul><p><strong>Returns</strong></p><p><code>BallVector</code> containing P*v with rigorous error bounds.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([1.0 2.0; 0.0 3.0], fill(1e-10, 2, 2))
result = compute_spectral_projector_schur(A, 1:1)

v = BallVector([1.0, 2.0], [1e-10, 1e-10])
v_projected = project_vector_spectral(v, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projection_schur.jl#L413-L434">source</a></section><section><div><pre><code class="language-julia hljs">project_vector_spectral(v::AbstractVector, result::SchurSpectralProjectorResult)</code></pre><p>Project standard vector onto eigenspace (non-verified version).</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractVector</code>: Vector to project</li><li><code>result::SchurSpectralProjectorResult</code>: Precomputed projector</li></ul><p><strong>Returns</strong></p><p>Projected vector P*v (center value only, no error bounds).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projection_schur.jl#L440-L451">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.verify_spectral_projector_properties"><a class="docstring-binding" href="#BallArithmetic.verify_spectral_projector_properties"><code>BallArithmetic.verify_spectral_projector_properties</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">verify_spectral_projector_properties(result::SchurSpectralProjectorResult, A::BallMatrix;
                                     tol::Real=1e-10)</code></pre><p>Verify that the computed spectral projector satisfies expected mathematical properties.</p><p><strong>Checks</strong></p><ol><li><strong>Idempotency</strong>: ‖P² - P‖₂ &lt; tol</li><li><strong>Bounded norm</strong>: ‖P‖₂ &lt; ∞ (typically ‖P‖₂ ≤ κ(V) where κ is condition number of eigenvectors)</li><li><strong>Commutation</strong> (if A normal): ‖A<em>P - P</em>A‖₂ &lt; tol</li><li><strong>Eigenvalue separation</strong>: min|λᵢ - λⱼ| &gt; 0 for i ∈ S, j ∉ S</li></ol><p><strong>Arguments</strong></p><ul><li><code>result::SchurSpectralProjectorResult</code>: Computed projector</li><li><code>A::BallMatrix</code>: Original matrix</li><li><code>tol::Real=1e-10</code>: Tolerance for property verification</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if all properties satisfied, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/spectral_projection_schur.jl#L458-L477">source</a></section></details></article><h2 id="Schur-Refinement"><a class="docs-heading-anchor" href="#Schur-Refinement">Schur Refinement</a><a id="Schur-Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Schur-Refinement" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.SchurRefinementResult"><a class="docstring-binding" href="#BallArithmetic.SchurRefinementResult"><code>BallArithmetic.SchurRefinementResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SchurRefinementResult{T, RT}</code></pre><p>Result from iterative Schur refinement to higher precision.</p><p><strong>Fields</strong></p><ul><li><code>Q::Matrix{T}</code>: Refined orthogonal/unitary Schur basis</li><li><code>T::Matrix{T}</code>: Refined upper triangular Schur form</li><li><code>iterations::Int</code>: Number of refinement iterations performed</li><li><code>residual_norm::RT</code>: Final residual ‖stril(Q^H A Q)‖₂ / ‖A‖_F — rigorous upper bound (real type)</li><li><code>orthogonality_defect::RT</code>: Final ‖Q^H Q - I‖₂ — rigorous upper bound (real type)</li><li><code>converged::Bool</code>: Whether refinement converged to desired tolerance</li></ul><p><strong>References</strong></p><ul><li>[<a href="../../references/#BujanovicKressnerSchroder2022">9</a>] Bujanović, Kressner &amp; Schröder, &quot;Iterative refinement of Schur decompositions&quot;, Numer. Algorithms 95, 247–267 (2024)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/iterative_schur_refinement.jl#L8-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.refine_schur_decomposition"><a class="docstring-binding" href="#BallArithmetic.refine_schur_decomposition"><code>BallArithmetic.refine_schur_decomposition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">refine_schur_decomposition(A::AbstractMatrix{T}, Q0::Matrix, T0::Matrix;
                            target_precision::Int=256,
                            max_iterations::Int=20,
                            tol::Real=0.0) where T</code></pre><p>Refine an approximate Schur decomposition A ≈ Q₀ T₀ Q₀^H to higher precision.</p><p>Starting from an approximate Schur decomposition computed in Float64, this function iteratively refines Q and T to achieve the accuracy of <code>target_precision</code> bits. The algorithm uses Newton-like iterations that converge quadratically.</p><p><strong>Algorithm (from Bujanović et al. 2022, Algorithm 4)</strong></p><p>Given A = Q₀ T₀ Q₀^H + E where E is the initial error:</p><ol><li><p><strong>Pre-computation</strong> (2 high-precision matrix multiplications):</p><ul><li>Compute A<em>Q = A * Q and Q^H</em>A = Q^H * A in target precision</li></ul></li><li><p><strong>Iteration</strong> (4 high-precision matrix multiplications per step):</p><ul><li>Compute residual R = Q^H * A_Q - T</li><li>Extract diagonal correction: T_new = T + diag(R)</li><li>Solve Sylvester equations for off-diagonal corrections</li><li>Apply Newton-Schulz to re-orthogonalize Q</li><li>Repeat until convergence</li></ul></li></ol><p>The method achieves 10-20× speedup over computing Schur directly in high precision.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Original matrix (will be converted to target precision)</li><li><code>Q0</code>: Approximate orthogonal/unitary factor from Schur decomposition</li><li><code>T0</code>: Approximate upper triangular factor from Schur decomposition</li><li><code>target_precision</code>: Target precision in bits (default: 256 for BigFloat)</li><li><code>max_iterations</code>: Maximum refinement iterations (default: 20)</li><li><code>tol</code>: Convergence tolerance (default: machine epsilon of target precision)</li></ul><p><strong>Returns</strong></p><p><a href="#BallArithmetic.SchurRefinementResult"><code>SchurRefinementResult</code></a> containing refined Q, T and convergence information.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using BallArithmetic, LinearAlgebra

# Compute Schur in Float64
A = randn(100, 100)
F = schur(A)
Q0, T0 = F.Z, F.T

# Refine to BigFloat precision
result = refine_schur_decomposition(A, Q0, T0; target_precision=256)

# Check residual
@show result.residual_norm      # Should be ≈ 10^-77 for 256-bit precision
@show result.orthogonality_defect</code></pre><p><strong>References</strong></p><ul><li>[<a href="../../references/#BujanovicKressnerSchroder2022">9</a>] Bujanović, Kressner &amp; Schröder, &quot;Iterative refinement of Schur decompositions&quot;, Numer. Algorithms 95, 247–267 (2024). Algorithm 4: Mixed-precision Schur refinement.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/iterative_schur_refinement.jl#L390-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.rigorous_schur_bigfloat"><a class="docstring-binding" href="#BallArithmetic.rigorous_schur_bigfloat"><code>BallArithmetic.rigorous_schur_bigfloat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rigorous_schur_bigfloat(A::BallMatrix{T}; target_precision::Int=256,
                        max_iterations::Int=20,
                        schur_seed=nothing) where T</code></pre><p>Compute rigorous Schur decomposition with BigFloat precision using iterative refinement.</p><p>This combines:</p><ol><li>Fast approximate Schur decomposition in Float64 (or use <code>schur_seed</code>)</li><li>Iterative refinement to BigFloat precision</li><li>Rigorous error certification via <a href="#BallArithmetic.certify_schur_decomposition"><code>certify_schur_decomposition</code></a></li></ol><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: Input ball matrix</li><li><code>target_precision</code>: Target BigFloat precision in bits (default: 256)</li><li><code>max_iterations</code>: Maximum refinement iterations (default: 20)</li><li><code>schur_seed</code>: Optional <code>(Q0, T0)</code> tuple — external Schur seed to use instead of computing a Float64 Schur internally.  Useful when an accurate decomposition is already available (e.g. from <code>GenericSchur.schur</code> in BigFloat).</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(Q_ball, T_ball, result)</code> where:</p><ul><li><code>Q_ball::BallMatrix{BigFloat}</code>: Rigorous enclosure of Schur basis</li><li><code>T_ball::BallMatrix{BigFloat}</code>: Rigorous enclosure of Schur form</li><li><code>result::SchurRefinementResult</code>: Refinement diagnostics</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix(randn(10, 10), fill(1e-10, 10, 10))
Q, T, result = rigorous_schur_bigfloat(A; target_precision=512)
@show result.converged

# With external seed:
F = schur(Complex{BigFloat}.(mid(A)))
Q2, T2, r2 = rigorous_schur_bigfloat(A; schur_seed=(F.Z, F.T))</code></pre><p><strong>References</strong></p><ul><li>[<a href="../../references/#BujanovicKressnerSchroder2022">9</a>] for the iterative refinement algorithm</li><li>[<a href="../../references/#Rump2010">12</a>] for rigorous error certification</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/iterative_schur_refinement.jl#L697-L737">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.certify_schur_decomposition"><a class="docstring-binding" href="#BallArithmetic.certify_schur_decomposition"><code>BallArithmetic.certify_schur_decomposition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">certify_schur_decomposition(A::BallMatrix, result::SchurRefinementResult)</code></pre><p>Wrap a <a href="#BallArithmetic.SchurRefinementResult"><code>SchurRefinementResult</code></a> in <code>BallMatrix</code> form with rigorous error bounds.</p><p>Given an input ball matrix <code>A</code> and a <code>SchurRefinementResult</code> from <a href="#BallArithmetic.refine_schur_decomposition"><code>refine_schur_decomposition</code></a>, construct <code>BallMatrix</code> enclosures of the Schur factors <code>Q</code> and <code>T</code>.  The radii are derived from:</p><ul><li>The <strong>orthogonality defect</strong> <code>‖Q^H Q - I‖₂</code> (contributes to <code>Q</code> radius)</li><li>The <strong>residual norm</strong> <code>‖stril(Q^H A Q)‖₂ / ‖A‖_F</code> (contributes to <code>T</code> radius)</li><li>The <strong>input uncertainty</strong> <code>rad(A)</code> (propagated to both)</li></ul><p>The BigFloat precision is automatically matched to the precision of <code>result.Q</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A::BallMatrix</code>: The original input matrix (provides <code>rad(A)</code> for uncertainty propagation)</li><li><code>result::SchurRefinementResult</code>: Refinement output with <code>Q</code>, <code>T</code>, and diagnostics</li></ul><p><strong>Returns</strong></p><p><code>(Q_ball, T_ball)</code> — <code>BallMatrix</code> enclosures of the Schur factors.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix(randn(ComplexF64, 5, 5), fill(1e-10, 5, 5))
F = schur(mid(A))
result = refine_schur_decomposition(mid(A), F.Z, F.T; target_precision=256)
Q_ball, T_ball = certify_schur_decomposition(A, result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/iterative_schur_refinement.jl#L638-L667">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.newton_schulz_orthogonalize!"><a class="docstring-binding" href="#BallArithmetic.newton_schulz_orthogonalize!"><code>BallArithmetic.newton_schulz_orthogonalize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">newton_schulz_orthogonalize!(Q::Matrix{T}; max_iter=10, tol=nothing) where T</code></pre><p>Apply Newton-Schulz iteration to orthogonalize Q in-place.</p><p>The iteration is:     Q<em>{k+1} = (1/2) Q</em>k (3I - Q<em>k^H Q</em>k)</p><p>This converges quadratically if ‖Q^H Q - I‖₂ &lt; 1.</p><p><strong>Arguments</strong></p><ul><li><code>Q</code>: Matrix to orthogonalize (modified in place)</li><li><code>max_iter</code>: Maximum iterations (default: 10)</li><li><code>tol</code>: Convergence tolerance (default: machine epsilon of T)</li></ul><p><strong>Returns</strong></p><ul><li>Number of iterations performed</li><li>Final orthogonality defect ‖Q^H Q - I‖_F</li></ul><p><strong>References</strong></p><ul><li>[<a href="../../references/#BujanovicKressnerSchroder2022">9</a>] Section 2.2.2 (Newton-Schulz iteration)</li></ul><p><strong>NOTE: This is an ORACLE computation - convergence is checked via the defect</strong></p><p><strong>(‖Q^H Q - I‖_F &lt; tol), which serves as an A POSTERIORI verification. The</strong></p><p><strong>intermediate computations don&#39;t need directed rounding because the final</strong></p><p><strong>defect measurement validates the orthogonalization quality.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/iterative_schur_refinement.jl#L49-L75">source</a></section></details></article><h2 id="Riesz-Projections"><a class="docs-heading-anchor" href="#Riesz-Projections">Riesz Projections</a><a id="Riesz-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Riesz-Projections" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.project_onto_eigenspace"><a class="docstring-binding" href="#BallArithmetic.project_onto_eigenspace"><code>BallArithmetic.project_onto_eigenspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_onto_eigenspace(v::AbstractVector, V::AbstractMatrix, indices::UnitRange{Int};
                        hermitian::Bool=false, left_eigenvectors::Union{Nothing, AbstractMatrix}=nothing)</code></pre><p>Project vector <code>v</code> onto the eigenspace spanned by eigenvectors at the specified indices.</p><p><strong>Mathematical Background</strong></p><p>For a diagonalizable matrix A = VΛV⁻¹, the Riesz projection onto the eigenspace corresponding to eigenvalues λ_k (k ∈ indices) is:</p><p><strong>Hermitian/Normal case</strong> (hermitian=true or V orthogonal):</p><pre><code class="language-julia hljs">P_S v = V_S (V_S^† V_S)⁻¹ V_S^† v = V_S V_S^† v</code></pre><p>where V_S = V[:, indices] and V^† is the conjugate transpose.</p><p><strong>Non-normal case</strong> (requires left eigenvectors):</p><pre><code class="language-julia hljs">P_S v = V_S W_S^† v</code></pre><p>where W_S contains the corresponding left eigenvectors (rows of V⁻¹).</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractVector</code>: Vector to project (length n)</li><li><code>V::AbstractMatrix</code>: Matrix of right eigenvectors (n × n)</li><li><code>indices::UnitRange{Int}</code>: Column indices of eigenvectors to project onto</li><li><code>hermitian::Bool=false</code>: If true, assumes V is orthogonal (V^† V = I)</li><li><code>left_eigenvectors::Union{Nothing, AbstractMatrix}=nothing</code>: Left eigenvectors W = V⁻¹ (required for non-normal matrices when hermitian=false)</li></ul><p><strong>Returns</strong></p><p>Projected vector P_S v of length n.</p><p><strong>Examples</strong></p><p><strong>Symmetric/Hermitian case</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, BallArithmetic

# Symmetric matrix with clustered eigenvalues
A = [4.0 1.0 0.0; 1.0 4.0 0.0; 0.0 0.0 10.0]
F = eigen(Symmetric(A))

# Project onto first two eigenvectors (eigenvalues ≈ 3, 5)
v = [1.0, 2.0, 3.0]
v_proj = project_onto_eigenspace(v, F.vectors, 1:2; hermitian=true)</code></pre><p><strong>Non-normal case (requires left eigenvectors)</strong></p><pre><code class="language-julia hljs"># Non-normal matrix
A = [1.0 1.0; 0.0 2.0]  # Upper triangular, non-symmetric
F = eigen(A)

# Compute left eigenvectors
V_inv = inv(F.vectors)  # Rows are left eigenvectors

# Project onto first eigenspace
v = [1.0, 1.0]
v_proj = project_onto_eigenspace(v, F.vectors, 1:1;
                                  hermitian=false, left_eigenvectors=V_inv)</code></pre><p><strong>Notes</strong></p><ul><li>For hermitian=true, uses the simple formula P = V<em>S V</em>S^†</li><li>For hermitian=false without left eigenvectors, attempts V⁻¹ computation (may fail)</li><li>For non-normal matrices, providing left_eigenvectors avoids computing V⁻¹</li><li>The projection is exact in exact arithmetic but subject to rounding errors</li><li>For verified computation, use <code>verified_project_onto_eigenspace</code> with BallMatrix</li></ul><p><strong>References</strong></p><ul><li>Kato, T. &quot;Perturbation theory for linear operators&quot; (1995), Chapter II</li><li>Stewart, G. W., Sun, J. &quot;Matrix Perturbation Theory&quot; (1990), Section V.3</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/riesz_projections.jl#L5-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.project_onto_schur_subspace"><a class="docstring-binding" href="#BallArithmetic.project_onto_schur_subspace"><code>BallArithmetic.project_onto_schur_subspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">project_onto_schur_subspace(v::AbstractVector, Q::AbstractMatrix, indices::UnitRange{Int})</code></pre><p>Project vector <code>v</code> onto the invariant subspace spanned by Schur vectors at specified indices.</p><p><strong>Mathematical Background</strong></p><p>For a Schur decomposition A = QTQ^†, the Schur vectors (columns of Q) span nested invariant subspaces. The projection onto the subspace spanned by Q[:, indices] is:</p><pre><code class="language-julia hljs">P_S v = Q_S Q_S^† v</code></pre><p>where Q_S = Q[:, indices]. Since Q is unitary (Q^† Q = I), this is always well-defined.</p><p><strong>Arguments</strong></p><ul><li><code>v::AbstractVector</code>: Vector to project (length n)</li><li><code>Q::AbstractMatrix</code>: Unitary Schur matrix (n × n, with Q^† Q = I)</li><li><code>indices::UnitRange{Int}</code>: Column indices of Schur vectors to project onto</li></ul><p><strong>Returns</strong></p><p>Projected vector P_S v of length n.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LinearAlgebra, BallArithmetic

# Matrix with complex eigenvalues
A = [0.0 1.0; -1.0 0.0]  # Rotation matrix
F = schur(A)

# Project onto first Schur vector
v = [1.0, 1.0]
v_proj = project_onto_schur_subspace(v, F.Z, 1:1)</code></pre><p><strong>Notes</strong></p><ul><li>Schur vectors are always orthonormal, so projection is straightforward</li><li>The subspace spanned by Q[:, 1:k] is an invariant subspace of A</li><li>For real Schur form, complex eigenvalue pairs share a 2D invariant subspace</li><li>This is simpler than eigenspace projection for non-normal matrices</li></ul><p><strong>References</strong></p><ul><li>Golub, G. H., Van Loan, C. F. &quot;Matrix Computations&quot; (2013), Section 7.6</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/riesz_projections.jl#L123-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.verified_project_onto_eigenspace"><a class="docstring-binding" href="#BallArithmetic.verified_project_onto_eigenspace"><code>BallArithmetic.verified_project_onto_eigenspace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">verified_project_onto_eigenspace(v::BallVector, V::BallMatrix, indices::UnitRange{Int};
                                 hermitian::Bool=false)</code></pre><p>Rigorously verified projection of interval vector onto eigenspace with error bounds.</p><p>Similar to <a href="#BallArithmetic.project_onto_eigenspace"><code>project_onto_eigenspace</code></a> but uses interval arithmetic to provide rigorous bounds on the projection result accounting for uncertainties in both the vector and eigenvector matrix.</p><p><strong>Arguments</strong></p><ul><li><code>v::BallVector</code>: Interval vector to project</li><li><code>V::BallMatrix</code>: Interval matrix of eigenvectors</li><li><code>indices::UnitRange{Int}</code>: Column indices of eigenvectors</li><li><code>hermitian::Bool=false</code>: If true, assumes V is orthogonal</li></ul><p><strong>Returns</strong></p><p><code>BallVector</code> containing the projected vector with rigorous error bounds.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using BallArithmetic, LinearAlgebra

# Matrix with small uncertainties
A = BallMatrix([4.0 1.0; 1.0 3.0], fill(1e-10, 2, 2))
F = eigen(Symmetric(A.c))

# Vector with uncertainties
v = BallVector([1.0, 2.0], [1e-10, 1e-10])

# Verified projection
V_ball = BallMatrix(F.vectors)
v_proj = verified_project_onto_eigenspace(v, V_ball, 1:1; hermitian=true)</code></pre><p><strong>Notes</strong></p><ul><li>Uses interval arithmetic throughout for rigorous error bounds</li><li>The Gram system <code>G·c = V_S†·v</code> is solved rigorously via <code>krawczyk_linear_system</code>; if Krawczyk does not verify, a Neumann-series residual bound is used as fallback</li><li>Result contains all possible projections for vectors/eigenvectors in input intervals</li><li>More expensive than non-verified version due to interval arithmetic overhead</li><li>Currently only supports hermitian case (non-normal requires Sylvester solver)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/riesz_projections.jl#L185-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_eigenspace_projector"><a class="docstring-binding" href="#BallArithmetic.compute_eigenspace_projector"><code>BallArithmetic.compute_eigenspace_projector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_eigenspace_projector(V::AbstractMatrix, indices::UnitRange{Int};
                            hermitian::Bool=false,
                            left_eigenvectors::Union{Nothing, AbstractMatrix}=nothing)</code></pre><p>Compute the projection matrix P_S onto the eigenspace spanned by specified eigenvectors.</p><p>Returns the n × n projection matrix P<em>S such that P</em>S v projects any vector v onto the specified eigenspace.</p><p><strong>Arguments</strong></p><ul><li><code>V::AbstractMatrix</code>: Matrix of right eigenvectors (n × n)</li><li><code>indices::UnitRange{Int}</code>: Column indices of eigenvectors defining the subspace</li><li><code>hermitian::Bool=false</code>: If true, assumes V is orthogonal</li><li><code>left_eigenvectors::Union{Nothing, AbstractMatrix}=nothing</code>: Left eigenvectors W = V⁻¹</li></ul><p><strong>Returns</strong></p><p>n × n projection matrix P<em>S with P</em>S² = P_S.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">F = eigen(A)
P = compute_eigenspace_projector(F.vectors, 1:2; hermitian=true)

# Now can project multiple vectors
v1_proj = P * v1
v2_proj = P * v2</code></pre><p><strong>See Also</strong></p><ul><li><a href="#BallArithmetic.project_onto_eigenspace"><code>project_onto_eigenspace</code></a>: Project single vector without forming matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/riesz_projections.jl#L295-L326">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_schur_projector"><a class="docstring-binding" href="#BallArithmetic.compute_schur_projector"><code>BallArithmetic.compute_schur_projector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_schur_projector(Q::AbstractMatrix, indices::UnitRange{Int})</code></pre><p>Compute the projection matrix onto the invariant subspace spanned by Schur vectors.</p><p>Returns the n × n projection matrix P<em>S = Q</em>S Q<em>S^† where Q</em>S = Q[:, indices].</p><p><strong>Arguments</strong></p><ul><li><code>Q::AbstractMatrix</code>: Unitary Schur matrix (n × n)</li><li><code>indices::UnitRange{Int}</code>: Column indices of Schur vectors</li></ul><p><strong>Returns</strong></p><p>n × n projection matrix P<em>S with P</em>S² = P_S.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">F = schur(A)
P = compute_schur_projector(F.Z, 1:3)  # Project onto first 3-dimensional invariant subspace</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/eigenvalues/riesz_projections.jl#L356-L375">source</a></section></details></article><h2 id="Singular-Value-Intervals"><a class="docs-heading-anchor" href="#Singular-Value-Intervals">Singular Value Intervals</a><a id="Singular-Value-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Intervals" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.qi_intervals"><a class="docstring-binding" href="#BallArithmetic.qi_intervals"><code>BallArithmetic.qi_intervals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qi_intervals(A::BallMatrix)</code></pre><p>Qi (1984, Theorem 2) intervals for singular values. Returns the intervals <code>Bᵢ</code> as a <code>Vector{Ball}</code>. See Ref. [<a href="../../references/#Qi1984">13</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/singular_gerschgorin.jl#L15-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.qi_sqrt_intervals"><a class="docstring-binding" href="#BallArithmetic.qi_sqrt_intervals"><code>BallArithmetic.qi_sqrt_intervals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qi_sqrt_intervals(A::BallMatrix)</code></pre><p>Sharper square-root intervals for the singular values (Qi 1984, Theorem 3). See Ref. [<a href="../../references/#Qi1984">13</a>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e1a72a718cfd3e254287793e1fd8d011da015ebd/src/decompositions/svd/singular_gerschgorin.jl#L51-L56">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linearsystems/">« Linear Systems</a><a class="docs-footer-nextpage" href="../certifscripts/">CertifScripts »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 19 February 2026 17:52">Thursday 19 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
