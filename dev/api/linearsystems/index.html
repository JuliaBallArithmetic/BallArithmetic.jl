<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Systems · BallArithmetic.jl</title><meta name="title" content="Linear Systems · BallArithmetic.jl"/><meta property="og:title" content="Linear Systems · BallArithmetic.jl"/><meta property="twitter:title" content="Linear Systems · BallArithmetic.jl"/><meta name="description" content="Documentation for BallArithmetic.jl."/><meta property="og:description" content="Documentation for BallArithmetic.jl."/><meta property="twitter:description" content="Documentation for BallArithmetic.jl."/><meta property="og:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/linearsystems/"/><meta property="twitter:url" content="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/linearsystems/"/><link rel="canonical" href="https://juliaballarithmetic.github.io/BallArithmetic.jl/api/linearsystems/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BallArithmetic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../decompositions/">Matrix Decompositions</a></li><li><a class="tocitem" href="../../svd/">SVD</a></li><li><a class="tocitem" href="../../eigenvalues/">Eigenvalues</a></li><li><a class="tocitem" href="../../pseudospectra/">Pseudospectra</a></li><li><a class="tocitem" href="../../linearsystems/">Linear Systems</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/">Overview</a></li><li><a class="tocitem" href="../core/">Core Types</a></li><li class="is-active"><a class="tocitem" href>Linear Systems</a><ul class="internal"><li><a class="tocitem" href="#Gaussian-Elimination"><span>Gaussian Elimination</span></a></li><li><a class="tocitem" href="#Iterative-Methods"><span>Iterative Methods</span></a></li><li><a class="tocitem" href="#HBR-Method"><span>HBR Method</span></a></li><li><a class="tocitem" href="#Shaving"><span>Shaving</span></a></li><li><a class="tocitem" href="#Preconditioning"><span>Preconditioning</span></a></li><li><a class="tocitem" href="#Overdetermined-Systems"><span>Overdetermined Systems</span></a></li><li><a class="tocitem" href="#H-Matrix-Systems"><span>H-Matrix Systems</span></a></li><li><a class="tocitem" href="#Sylvester-Equations"><span>Sylvester Equations</span></a></li><li><a class="tocitem" href="#Matrix-Regularity"><span>Matrix Regularity</span></a></li><li><a class="tocitem" href="#Determinant-Bounds"><span>Determinant Bounds</span></a></li></ul></li><li><a class="tocitem" href="../eigenvalues/">Eigenvalues &amp; SVD</a></li><li><a class="tocitem" href="../certifscripts/">CertifScripts</a></li><li><a class="tocitem" href="../numericaltest/">NumericalTest</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Linear Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/main/docs/src/api/linearsystems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Linear-Systems"><a class="docs-heading-anchor" href="#API-Linear-Systems">API - Linear Systems</a><a id="API-Linear-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#API-Linear-Systems" title="Permalink"></a></h1><p>Verified linear system solvers and related functions.</p><h2 id="Gaussian-Elimination"><a class="docs-heading-anchor" href="#Gaussian-Elimination">Gaussian Elimination</a><a id="Gaussian-Elimination-1"></a><a class="docs-heading-anchor-permalink" href="#Gaussian-Elimination" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.GaussianEliminationResult"><a class="docstring-binding" href="#BallArithmetic.GaussianEliminationResult"><code>BallArithmetic.GaussianEliminationResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GaussianEliminationResult{T, VT}</code></pre><p>Result from interval Gaussian elimination.</p><p><strong>Fields</strong></p><ul><li><code>solution::VT</code>: Solution enclosure (or empty if singular)</li><li><code>success::Bool</code>: Whether elimination succeeded</li><li><code>singular::Bool</code>: Whether matrix is provably singular</li><li><code>L::Matrix</code>: Lower triangular factor (if computed)</li><li><code>U::BallMatrix</code>: Upper triangular factor</li><li><code>p::Vector{Int}</code>: Permutation vector (pivoting)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/gaussian_elimination.jl#L15-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.interval_gaussian_elimination"><a class="docstring-binding" href="#BallArithmetic.interval_gaussian_elimination"><code>BallArithmetic.interval_gaussian_elimination</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interval_gaussian_elimination(A::BallMatrix{T}, b::BallVector{T};
                              pivoting::Symbol=:partial,
                              store_factors::Bool=false) where {T}</code></pre><p>Solve Ax = b using interval Gaussian elimination with partial pivoting.</p><p><strong>Algorithm</strong></p><ol><li><p>Forward elimination with partial pivoting:</p><ul><li>For each column k, find pivot with maximum magnitude</li><li>Swap rows if needed</li><li>Eliminate entries below pivot</li><li>Check for singular matrix (zero on diagonal)</li></ul></li><li><p>Backward substitution:</p><ul><li>Solve Ux = y from bottom to top</li><li>x<em>i = (y</em>i - Σ<em>{j&gt;i} u</em>{ij}x<em>j) / u</em>{ii}</li></ul></li></ol><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (n×n)</li><li><code>b</code>: Right-hand side ball vector (n)</li><li><code>pivoting</code>: Pivoting strategy (<code>:partial</code> or <code>:none</code>)</li><li><code>store_factors</code>: Whether to store L and U factors</li></ul><p><strong>Returns</strong></p><p><code>GaussianEliminationResult</code> with solution and factorization information.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0 1.0; 4.0 3.0 3.0; 8.0 7.0 9.0], fill(1e-10, 3, 3))
b = BallVector([4.0, 10.0, 24.0], fill(1e-10, 3))

result = interval_gaussian_elimination(A, b)

if result.success
    println(&quot;Solution: &quot;, result.solution)
elseif result.singular
    println(&quot;Matrix is singular&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>O(n³) complexity</li><li>Detects singularity during elimination</li><li>Partial pivoting improves numerical stability</li><li>Can suffer from overestimation (wrapping effect)</li><li>Preconditioning recommended for better accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/gaussian_elimination.jl#L43-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.interval_gaussian_elimination_det"><a class="docstring-binding" href="#BallArithmetic.interval_gaussian_elimination_det"><code>BallArithmetic.interval_gaussian_elimination_det</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interval_gaussian_elimination_det(A::BallMatrix{T}) where {T}</code></pre><p>Compute determinant enclosure using Gaussian elimination.</p><p><strong>Algorithm</strong></p><p>The determinant is the product of diagonal elements after elimination:     det(PA) = ∏<em>{i=1}^n u</em>{ii} × sign(permutation)</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Square ball matrix (n×n)</li></ul><p><strong>Returns</strong></p><p>Ball enclosure of the determinant.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0; 1.0 2.0], fill(1e-10, 2, 2))
det_enclosure = interval_gaussian_elimination_det(A)
println(&quot;det(A) ∈ &quot;, det_enclosure)</code></pre><p><strong>Notes</strong></p><ul><li>O(n³) complexity</li><li>Can suffer from overestimation</li><li>Zero in result indicates possible singularity</li><li>Useful for singularity detection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/gaussian_elimination.jl#L201-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.is_regular_gaussian_elimination"><a class="docstring-binding" href="#BallArithmetic.is_regular_gaussian_elimination"><code>BallArithmetic.is_regular_gaussian_elimination</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_regular_gaussian_elimination(A::BallMatrix{T}) where {T}</code></pre><p>Test if matrix [A] contains only regular (nonsingular) matrices using Gaussian elimination.</p><p><strong>Algorithm</strong></p><p>Perform Gaussian elimination and check if zero appears on diagonal. If zero does NOT appear, matrix is proven regular.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Square ball matrix (n×n)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if matrix is proven regular</li><li><code>false</code> if test is inconclusive</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(1e-10, 2, 2))

if is_regular_gaussian_elimination(A)
    println(&quot;Matrix is regular&quot;)
else
    println(&quot;Cannot determine regularity&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>Sufficient but not necessary test</li><li>O(n³) complexity</li><li>If returns true, regularity is guaranteed</li><li>If returns false, matrix may still be regular</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/gaussian_elimination.jl#L267-L299">source</a></section></details></article><h2 id="Iterative-Methods"><a class="docs-heading-anchor" href="#Iterative-Methods">Iterative Methods</a><a id="Iterative-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.IterativeResult"><a class="docstring-binding" href="#BallArithmetic.IterativeResult"><code>BallArithmetic.IterativeResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterativeResult{T, VT}</code></pre><p>Result from iterative interval linear system solver.</p><p><strong>Fields</strong></p><ul><li><code>solution::VT</code>: Enclosure of the solution set</li><li><code>converged::Bool</code>: Whether the iteration converged</li><li><code>iterations::Int</code>: Number of iterations performed</li><li><code>final_width::T</code>: Maximum width of final solution components</li><li><code>convergence_rate::T</code>: Observed convergence rate (ratio of successive widths)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/iterative_methods.jl#L15-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.interval_gauss_seidel"><a class="docstring-binding" href="#BallArithmetic.interval_gauss_seidel"><code>BallArithmetic.interval_gauss_seidel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interval_gauss_seidel(A::BallMatrix{T}, b::BallVector{T};
                      x0::Union{Nothing, BallVector{T}}=nothing,
                      max_iterations::Int=100,
                      tol::T=T(1e-10),
                      use_epsilon_inflation::Bool=true,
                      ϵ::T=T(1e-15),
                      r::T=T(0.001)) where {T}</code></pre><p>Solve Ax = b using interval Gauss-Seidel iteration.</p><p><strong>Algorithm</strong></p><p>The Gauss-Seidel method updates each component x_i using:</p><pre><code class="language-julia hljs">x_i^(k+1) = (b_i - Σ_{j&lt;i} a_{ij}x_j^(k+1) - Σ_{j&gt;i} a_{ij}x_j^(k)) / a_{ii}</code></pre><p>where updated components x_j^(k+1) for j &lt; i are used immediately.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (n×n)</li><li><code>b</code>: Right-hand side ball vector (n)</li><li><code>x0</code>: Initial enclosure (computed if not provided)</li><li><code>max_iterations</code>: Maximum number of iterations</li><li><code>tol</code>: Convergence tolerance (maximum component width)</li><li><code>use_epsilon_inflation</code>: Apply ε-inflation before intersection</li><li><code>ϵ</code>: Absolute inflation factor</li><li><code>r</code>: Relative inflation factor</li></ul><p><strong>Returns</strong></p><p><code>IterativeResult</code> with solution enclosure and convergence information.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(1e-10, 2, 2))
b = BallVector([5.0, 4.0], fill(1e-10, 2))

result = interval_gauss_seidel(A, b)

if result.converged
    println(&quot;Solution: &quot;, result.solution)
    println(&quot;Iterations: &quot;, result.iterations)
end</code></pre><p><strong>Notes</strong></p><ul><li>Generally converges faster than Jacobi method</li><li>Converges for strictly diagonally dominant matrices</li><li>Uses most recent updates immediately (sequential updates)</li><li>ε-inflation helps ensure non-empty intersection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/iterative_methods.jl#L40-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.interval_jacobi"><a class="docstring-binding" href="#BallArithmetic.interval_jacobi"><code>BallArithmetic.interval_jacobi</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interval_jacobi(A::BallMatrix{T}, b::BallVector{T};
                x0::Union{Nothing, BallVector{T}}=nothing,
                max_iterations::Int=100,
                tol::T=T(1e-10),
                use_epsilon_inflation::Bool=true,
                ϵ::T=T(1e-15),
                r::T=T(0.001)) where {T}</code></pre><p>Solve Ax = b using interval Jacobi iteration.</p><p><strong>Algorithm</strong></p><p>The Jacobi method updates all components simultaneously:</p><pre><code class="language-julia hljs">x_i^(k+1) = (b_i - Σ_{j≠i} a_{ij}x_j^(k)) / a_{ii}</code></pre><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (n×n)</li><li><code>b</code>: Right-hand side ball vector (n)</li><li><code>x0</code>: Initial enclosure (computed if not provided)</li><li><code>max_iterations</code>: Maximum number of iterations</li><li><code>tol</code>: Convergence tolerance (maximum component width)</li><li><code>use_epsilon_inflation</code>: Apply ε-inflation before intersection</li><li><code>ϵ</code>: Absolute inflation factor</li><li><code>r</code>: Relative inflation factor</li></ul><p><strong>Returns</strong></p><p><code>IterativeResult</code> with solution enclosure and convergence information.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([4.0 1.0; 1.0 3.0], fill(1e-10, 2, 2))
b = BallVector([7.0, 6.0], fill(1e-10, 2))

result = interval_jacobi(A, b)

if result.converged
    println(&quot;Solution: &quot;, result.solution)
    println(&quot;Convergence rate: &quot;, result.convergence_rate)
end</code></pre><p><strong>Notes</strong></p><ul><li>Easily parallelizable (all updates independent)</li><li>Converges for strictly diagonally dominant matrices</li><li>Generally slower than Gauss-Seidel but more parallelizable</li><li>All components updated simultaneously (parallel updates)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/iterative_methods.jl#L194-L241">source</a></section></details></article><h2 id="HBR-Method"><a class="docs-heading-anchor" href="#HBR-Method">HBR Method</a><a id="HBR-Method-1"></a><a class="docs-heading-anchor-permalink" href="#HBR-Method" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.HBRResult"><a class="docstring-binding" href="#BallArithmetic.HBRResult"><code>BallArithmetic.HBRResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HBRResult{T, VT}</code></pre><p>Result from Hansen-Bliek-Rohn method.</p><p><strong>Fields</strong></p><ul><li><code>solution::VT</code>: Tight solution enclosure</li><li><code>success::Bool</code>: Whether all systems solved successfully</li><li><code>num_systems_solved::Int</code>: Number of real systems solved (≤ 2n)</li><li><code>max_residual::T</code>: Maximum residual from solved systems</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/hbr_method.jl#L16-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.hbr_method"><a class="docstring-binding" href="#BallArithmetic.hbr_method"><code>BallArithmetic.hbr_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hbr_method(A::BallMatrix{T}, b::BallVector{T};
           preconditioner::Union{Nothing, Matrix{T}}=nothing,
           check_residuals::Bool=true,
           residual_tol::T=T(1e-8)) where {T}</code></pre><p>Compute tight enclosure of Ax = b using Hansen-Bliek-Rohn method.</p><p><strong>Algorithm</strong></p><p>The HBR method computes the hull of the solution set by solving 2n real systems:</p><p>For each component i = 1, ..., n:</p><ol><li>Compute lower bound: Solve A<em>σ^i x = b</em>c where σ^i selects extremal matrix</li><li>Compute upper bound: Solve A<em>τ^i x = b</em>c where τ^i selects opposite extremal matrix</li></ol><p>The extremal matrices are chosen to minimize/maximize the i-th component.</p><p><strong>Mathematical Details</strong></p><p>For minimizing x_i:</p><ul><li>Choose A<em>σ entries: a</em>ij = inf(A<em>ij) if sgn(Ĉ</em>ji) ≥ 0, else sup(A_ij) where Ĉ = C^(-1) is the inverse preconditioner</li></ul><p>For maximizing x_i:</p><ul><li>Flip the selection rule</li></ul><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (n×n)</li><li><code>b</code>: Right-hand side ball vector (n)</li><li><code>preconditioner</code>: Approximate inverse C ≈ A^(-1) (computed if not provided)</li><li><code>check_residuals</code>: Verify solutions satisfy Oettli-Prager condition</li><li><code>residual_tol</code>: Tolerance for residual checking</li></ul><p><strong>Returns</strong></p><p><code>HBRResult</code> with tight solution enclosure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0; 1.0 2.0], fill(0.1, 2, 2))
b = BallVector([3.0, 3.0], fill(0.1, 2))

result = hbr_method(A, b)

if result.success
    println(&quot;Tight solution: &quot;, result.solution)
    println(&quot;Systems solved: &quot;, result.num_systems_solved)
end</code></pre><p><strong>Notes</strong></p><ul><li>O(n⁴) complexity - expensive but provides tightest enclosures</li><li>Solves 2n real linear systems</li><li>More accurate than Krawczyk or iterative methods</li><li>Recommended when high accuracy is required and n is small (n ≤ 20)</li><li>Requires good preconditioner for optimal vertex selection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/hbr_method.jl#L38-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.hbr_method_simple"><a class="docstring-binding" href="#BallArithmetic.hbr_method_simple"><code>BallArithmetic.hbr_method_simple</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hbr_method_simple(A::BallMatrix{T}, b::BallVector{T}) where {T}</code></pre><p>Simplified HBR method without preconditioner optimization.</p><p>Uses identity matrix as preconditioner, which may give suboptimal but still valid bounds.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (n×n)</li><li><code>b</code>: Right-hand side ball vector (n)</li></ul><p><strong>Returns</strong></p><p><code>HBRResult</code> with solution enclosure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([4.0 1.0; 1.0 3.0], fill(0.05, 2, 2))
b = BallVector([5.0, 4.0], fill(0.05, 2))

result = hbr_method_simple(A, b)
println(&quot;Solution: &quot;, result.solution)</code></pre><p><strong>Notes</strong></p><ul><li>Simpler but may not give tightest possible bounds</li><li>Uses identity matrix for vertex selection</li><li>Faster preconditioner computation</li><li>Still O(n⁴) due to 2n system solves</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/hbr_method.jl#L208-L236">source</a></section></details></article><h2 id="Shaving"><a class="docs-heading-anchor" href="#Shaving">Shaving</a><a id="Shaving-1"></a><a class="docs-heading-anchor-permalink" href="#Shaving" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.ShavingResult"><a class="docstring-binding" href="#BallArithmetic.ShavingResult"><code>BallArithmetic.ShavingResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ShavingResult{T, VT}</code></pre><p>Result from interval shaving method.</p><p><strong>Fields</strong></p><ul><li><code>solution::VT</code>: Shaved (refined) solution enclosure</li><li><code>shaved_amount::T</code>: Total amount shaved from all boundaries</li><li><code>iterations::Int</code>: Number of shaving passes performed</li><li><code>components_shaved::Int</code>: Number of component boundaries that were improved</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/shaving.jl#L15-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.interval_shaving"><a class="docstring-binding" href="#BallArithmetic.interval_shaving"><code>BallArithmetic.interval_shaving</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interval_shaving(A::BallMatrix{T}, b::BallVector{T}, x0::BallVector{T};
                 max_iterations::Int=10,
                 min_improvement::T=T(1e-6),
                 R::Union{Nothing, Matrix{T}}=nothing) where {T}</code></pre><p>Refine solution enclosure x0 by shaving infeasible boundaries using Sherman-Morrison updates.</p><p><strong>Algorithm</strong></p><p>For each component i and each boundary (lower/upper):</p><ol><li>Fix x_i at its boundary value</li><li>Update inverse using Sherman-Morrison formula</li><li>Compute bounds on x_i from remaining equations</li><li>If bound excludes fixed value, shrink interval</li><li>Repeat until no significant improvement</li></ol><p><strong>Mathematical Details</strong></p><p>When fixing x<em>i = α, the system becomes:     A * x = b  with  x</em>i = α</p><p>This is equivalent to:     (A with i-th column replaced by e_i) * x&#39; = b - α * A[:,i]</p><p>The inverse can be updated efficiently using Sherman-Morrison formula.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (n×n)</li><li><code>b</code>: Right-hand side ball vector (n)</li><li><code>x0</code>: Initial solution enclosure to be refined</li><li><code>max_iterations</code>: Maximum number of shaving passes</li><li><code>min_improvement</code>: Minimum relative improvement to continue shaving</li><li><code>R</code>: Preconditioner A^(-1) (computed if not provided)</li></ul><p><strong>Returns</strong></p><p><code>ShavingResult</code> with refined solution enclosure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(0.1, 2, 2))
b = BallVector([4.0, 3.0], fill(0.1, 2))

# Get initial enclosure (e.g., from Krawczyk)
result_krawczyk = krawczyk_linear_system(A, b)
x0 = result_krawczyk.solution

# Refine with shaving
result_shaved = interval_shaving(A, b, x0)

println(&quot;Original width: &quot;, maximum(rad(x0)))
println(&quot;Shaved width: &quot;, maximum(rad(result_shaved.solution)))
println(&quot;Improvement: &quot;, result_shaved.shaved_amount)</code></pre><p><strong>Notes</strong></p><ul><li>O(n²) per boundary test (efficient!)</li><li>Typically applied after Krawczyk or other method</li><li>Can significantly reduce interval widths</li><li>Diminishing returns after few iterations</li><li>Sherman-Morrison makes this practical</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/shaving.jl#L91-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.sherman_morrison_inverse_update"><a class="docstring-binding" href="#BallArithmetic.sherman_morrison_inverse_update"><code>BallArithmetic.sherman_morrison_inverse_update</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sherman_morrison_inverse_update(A_inv::Matrix{T}, u::Vector{T}, v::Vector{T}) where {T}</code></pre><p>Compute (A + uv^T)^(-1) using Sherman-Morrison formula.</p><p><strong>Sherman-Morrison Formula</strong></p><pre><code class="language-julia hljs">(A + uv^T)^(-1) = A^(-1) - (A^(-1)uv^T A^(-1)) / (1 + v^T A^(-1)u)</code></pre><p>This allows O(n²) update of inverse for rank-1 perturbation instead of O(n³) recomputation.</p><p><strong>Arguments</strong></p><ul><li><code>A_inv</code>: Inverse of base matrix A (n×n)</li><li><code>u</code>: First vector of rank-1 update (n)</li><li><code>v</code>: Second vector of rank-1 update (n)</li></ul><p><strong>Returns</strong></p><p>(A + uv^T)^(-1)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = [3.0 1.0; 1.0 2.0]
A_inv = inv(A)
u = [1.0, 0.0]
v = [0.0, 1.0]

# Efficiently compute inv(A + u*v&#39;)
A_updated_inv = sherman_morrison_inverse_update(A_inv, u, v)</code></pre><p><strong>Notes</strong></p><ul><li>O(n²) complexity vs O(n³) for full inverse</li><li>Numerically stable if |1 + v^T A^(-1)u| is not too small</li><li>Critical for efficient shaving implementation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/shaving.jl#L37-L70">source</a></section></details></article><h2 id="Preconditioning"><a class="docs-heading-anchor" href="#Preconditioning">Preconditioning</a><a id="Preconditioning-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioning" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.PreconditionerType"><a class="docstring-binding" href="#BallArithmetic.PreconditionerType"><code>BallArithmetic.PreconditionerType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PreconditionerType</code></pre><p>Enumeration of available preconditioning strategies.</p><ul><li><code>:midpoint</code>: C = A_c^(-1) (inverse of midpoint)</li><li><code>:lu</code>: C from LU factorization of midpoint</li><li><code>:ldlt</code>: C from LDLT factorization of midpoint (symmetric matrices)</li><li><code>:identity</code>: C = I (no preconditioning)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/preconditioning.jl#L14-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.PreconditionerResult"><a class="docstring-binding" href="#BallArithmetic.PreconditionerResult"><code>BallArithmetic.PreconditionerResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PreconditionerResult{T}</code></pre><p>Result from preconditioner computation.</p><p><strong>Fields</strong></p><ul><li><code>preconditioner::Matrix{T}</code>: Approximate inverse C</li><li><code>method::PreconditionerType</code>: Method used</li><li><code>condition_number::T</code>: Estimated condition number</li><li><code>success::Bool</code>: Whether computation succeeded</li><li><code>factorization::Any</code>: Stored factorization (for LU/LDLT)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/preconditioning.jl#L31-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.compute_preconditioner"><a class="docstring-binding" href="#BallArithmetic.compute_preconditioner"><code>BallArithmetic.compute_preconditioner</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_preconditioner(A::BallMatrix{T};
                      method::Symbol=:midpoint,
                      check_conditioning::Bool=true) where {T}</code></pre><p>Compute preconditioner C ≈ A^(-1) for interval matrix A.</p><p><strong>Methods</strong></p><ul><li><code>:midpoint</code>: Direct inverse of A_c (default, simplest)</li><li><code>:lu</code>: LU factorization of A_c (more stable)</li><li><code>:ldlt</code>: LDLT factorization of A_c (for symmetric A)</li><li><code>:identity</code>: Identity matrix (no preconditioning)</li></ul><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix to precondition</li><li><code>method</code>: Preconditioning strategy</li><li><code>check_conditioning</code>: Compute and warn about condition number</li></ul><p><strong>Returns</strong></p><p><code>PreconditionerResult</code> with approximate inverse and diagnostic info.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([4.0 1.0; 1.0 3.0], fill(0.1, 2, 2))

# Midpoint inverse (default)
prec = compute_preconditioner(A)
C = prec.preconditioner

# LU factorization (more stable)
prec_lu = compute_preconditioner(A, method=:lu)</code></pre><p><strong>Notes</strong></p><ul><li>Midpoint inverse: O(n³), simplest but may be numerically unstable</li><li>LU factorization: O(n³) once, O(n²) per solve, more stable</li><li>LDLT factorization: O(n³/6) once, O(n²) per solve, only for symmetric</li><li>Identity: O(1), use for well-conditioned or diagonally dominant matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/preconditioning.jl#L56-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.apply_preconditioner"><a class="docstring-binding" href="#BallArithmetic.apply_preconditioner"><code>BallArithmetic.apply_preconditioner</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_preconditioner(prec::PreconditionerResult{T}, v::Vector{T}) where {T}</code></pre><p>Apply preconditioner to vector: compute C * v.</p><p>If factorization is available, uses it for efficiency.</p><p><strong>Arguments</strong></p><ul><li><code>prec</code>: Preconditioner result from <code>compute_preconditioner</code></li><li><code>v</code>: Vector to multiply</li></ul><p><strong>Returns</strong></p><p>C * v</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(0.1, 2, 2))
prec = compute_preconditioner(A, method=:lu)

b = [5.0, 4.0]
Cb = apply_preconditioner(prec, b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/preconditioning.jl#L172-L194">source</a></section><section><div><pre><code class="language-julia hljs">apply_preconditioner(prec::PreconditionerResult{T}, M::Matrix{T}) where {T}</code></pre><p>Apply preconditioner to matrix: compute C * M.</p><p><strong>Arguments</strong></p><ul><li><code>prec</code>: Preconditioner result</li><li><code>M</code>: Matrix to multiply</li></ul><p><strong>Returns</strong></p><p>C * M</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/preconditioning.jl#L208-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.is_well_preconditioned"><a class="docstring-binding" href="#BallArithmetic.is_well_preconditioned"><code>BallArithmetic.is_well_preconditioned</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_well_preconditioned(A::BallMatrix{T}, prec::PreconditionerResult{T};
                      threshold::T=T(0.5)) where {T}</code></pre><p>Check if preconditioner is effective.</p><p>A good preconditioner should make ‖I - CA‖ small (ideally &lt; 0.5).</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Original interval matrix</li><li><code>prec</code>: Preconditioner result</li><li><code>threshold</code>: Threshold for ‖I - CA‖ (default 0.5)</li></ul><p><strong>Returns</strong></p><p><code>true</code> if ‖I - CA‖ &lt; threshold</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(0.1, 2, 2))
prec = compute_preconditioner(A)

if is_well_preconditioned(A, prec)
    println(&quot;Good preconditioner&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/preconditioning.jl#L233-L258">source</a></section></details></article><h2 id="Overdetermined-Systems"><a class="docs-heading-anchor" href="#Overdetermined-Systems">Overdetermined Systems</a><a id="Overdetermined-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Overdetermined-Systems" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.OverdeterminedResult"><a class="docstring-binding" href="#BallArithmetic.OverdeterminedResult"><code>BallArithmetic.OverdeterminedResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OverdeterminedResult{T, VT}</code></pre><p>Result from overdetermined interval linear system solver.</p><p><strong>Fields</strong></p><ul><li><code>solution::VT</code>: Solution enclosure (or empty if unsolvable)</li><li><code>solvable::Bool</code>: Whether system is proven solvable</li><li><code>method::Symbol</code>: Method used</li><li><code>subsystems_checked::Int</code>: Number of subsystems examined</li><li><code>residual::T</code>: Maximum residual norm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/overdetermined.jl#L16-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.subsquares_method"><a class="docstring-binding" href="#BallArithmetic.subsquares_method"><code>BallArithmetic.subsquares_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subsquares_method(A::BallMatrix{T}, b::BallVector{T};
                 max_subsystems::Int=1000,
                 solver::Symbol=:gaussian_elimination) where {T}</code></pre><p>Solve overdetermined system Ax = b using subsquares approach.</p><p><strong>Algorithm</strong></p><p>For m×n system with m &gt; n:</p><ol><li>Consider all (m choose n) square subsystems</li><li>Solve each n×n subsystem</li><li>Check if solution satisfies all m equations (Oettli-Prager)</li><li>Take hull of all valid solutions</li></ol><p><strong>Mathematical Background</strong></p><p>A solution exists if at least one n×n subsystem has a solution that satisfies all m equations.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (m×n, m &gt; n)</li><li><code>b</code>: Right-hand side ball vector (m)</li><li><code>max_subsystems</code>: Maximum number of subsystems to check</li><li><code>solver</code>: Solver for square subsystems (<code>:gaussian_elimination</code>, <code>:krawczyk</code>)</li></ul><p><strong>Returns</strong></p><p><code>OverdeterminedResult</code> with solution enclosure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0; 1.0 2.0; 3.0 1.0], fill(0.1, 3, 2))
b = BallVector([3.0, 3.0, 4.0], fill(0.1, 3))

result = subsquares_method(A, b)

if result.solvable
    println(&quot;Solution: &quot;, result.solution)
    println(&quot;Checked &quot;, result.subsystems_checked, &quot; subsystems&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>Combinatorial complexity: O(C(m,n) × n³)</li><li>Only practical for small m and n</li><li>Guaranteed to find solution if one exists (complete method)</li><li>May be very slow for large m or n</li><li>Recommended: m ≤ 20, n ≤ 10</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/overdetermined.jl#L41-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.multi_jacobi_method"><a class="docstring-binding" href="#BallArithmetic.multi_jacobi_method"><code>BallArithmetic.multi_jacobi_method</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multi_jacobi_method(A::BallMatrix{T}, b::BallVector{T};
                   x0::Union{Nothing, BallVector{T}}=nothing,
                   max_iterations::Int=100,
                   tol::T=T(1e-10)) where {T}</code></pre><p>Solve overdetermined system using Multi-Jacobi iteration.</p><p><strong>Algorithm</strong></p><p>For each variable x_j, compute intersection of bounds from all equations:</p><pre><code class="language-julia hljs">x_j^(k+1) = ⋂_{i=1}^m [(b_i - ∑_{l≠j} a_{il}x_l^(k)) / a_{ij}]</code></pre><p>where the intersection is over all rows i where a_{ij} ≠ 0.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (m×n, m &gt; n)</li><li><code>b</code>: Right-hand side ball vector (m)</li><li><code>x0</code>: Initial enclosure (computed if not provided)</li><li><code>max_iterations</code>: Maximum iterations</li><li><code>tol</code>: Convergence tolerance</li></ul><p><strong>Returns</strong></p><p><code>OverdeterminedResult</code> with solution enclosure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0; 2.0 3.0], fill(0.1, 3, 2))
b = BallVector([4.0, 3.0, 5.0], fill(0.1, 3))

result = multi_jacobi_method(A, b)

if result.solvable
    println(&quot;Solution: &quot;, result.solution)
    println(&quot;Iterations: &quot;, result.subsystems_checked)
end</code></pre><p><strong>Notes</strong></p><ul><li>O(mn²) per iteration - faster than subsquares</li><li>May not converge for all systems</li><li>Empty intersection indicates unsolvability</li><li>Works well when system is &quot;nearly square&quot; or well-conditioned</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/overdetermined.jl#L195-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.interval_least_squares"><a class="docstring-binding" href="#BallArithmetic.interval_least_squares"><code>BallArithmetic.interval_least_squares</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interval_least_squares(A::BallMatrix{T}, b::BallVector{T};
                      method::Symbol=:normal_equations) where {T}</code></pre><p>Compute interval least squares solution to overdetermined system.</p><p>Minimizes ||Ax - b||² over the interval matrix/vector.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix (m×n, m ≥ n)</li><li><code>b</code>: Right-hand side ball vector (m)</li><li><code>method</code>: Solution method (<code>:normal_equations</code> or <code>:qr</code>)</li></ul><p><strong>Returns</strong></p><p><code>OverdeterminedResult</code> with least squares solution enclosure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0; 1.0 2.0; 3.0 1.0], fill(0.1, 3, 2))
b = BallVector([3.1, 2.9, 4.2], fill(0.05, 3))

result = interval_least_squares(A, b)
println(&quot;LS solution: &quot;, result.solution)</code></pre><p><strong>Notes</strong></p><ul><li>Solves normal equations: A^T A x = A^T b</li><li>O(mn² + n³) complexity</li><li>May not satisfy all equations exactly</li><li>Useful when exact solution doesn&#39;t exist</li><li>Returns minimum norm solution in interval sense</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/overdetermined.jl#L342-L373">source</a></section></details></article><h2 id="H-Matrix-Systems"><a class="docs-heading-anchor" href="#H-Matrix-Systems">H-Matrix Systems</a><a id="H-Matrix-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#H-Matrix-Systems" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.VerifiedLinearSystemResult"><a class="docstring-binding" href="#BallArithmetic.VerifiedLinearSystemResult"><code>BallArithmetic.VerifiedLinearSystemResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VerifiedLinearSystemResult</code></pre><p>Result structure for verified linear system solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/verified_linear_system_hmatrix.jl#L17-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.verified_linear_solve_hmatrix"><a class="docstring-binding" href="#BallArithmetic.verified_linear_solve_hmatrix"><code>BallArithmetic.verified_linear_solve_hmatrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">verified_linear_solve_hmatrix(A::BallMatrix, b::BallVector;
                               method=:improved_method_a,
                               R=nothing,
                               x_approx=nothing,
                               max_iterations=1,
                               compute_perron_vector=true)</code></pre><p>Compute verified error bounds for the solution of Ax = b using H-matrix properties.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Coefficient ball matrix</li><li><code>b</code>: Right-hand side ball vector</li><li><code>method</code>: Verification method to use<ul><li><code>:rump_original</code> - Original Rump (2013) bound (Theorem 3.1)</li><li><code>:minamihata_2015</code> - Minamihata et al. (2015) bound (Theorem 3.2, m=1)</li><li><code>:improved_method_a</code> - Improved bound for Method (a) (Theorem 3.3, default)</li><li><code>:improved_method_b</code> - Improved bound for Method (b) (Corollary 3.2)</li></ul></li><li><code>R</code>: Approximate inverse of A (computed if not provided)</li><li><code>x_approx</code>: Approximate solution (computed if not provided)</li><li><code>max_iterations</code>: Number of refinement iterations for improved bounds</li><li><code>compute_perron_vector</code>: Whether to compute Perron vector (more accurate)</li></ul><p><strong>Returns</strong></p><ul><li><code>VerifiedLinearSystemResult</code> containing verified error bounds</li></ul><p><strong>Method Comparison</strong></p><ul><li><strong>Method (a)</strong>: Uses C = [▽(RA), △(RA)] - more expensive but tighter</li><li><strong>Method (b)</strong>: Uses C = [▽(RA), ▽(RA) + 2nu|R||A|] - half cost, weaker bounds</li></ul><p>The improved methods (Theorem 3.3 and Corollary 3.2) provide tighter bounds than conventional approaches, especially for ill-conditioned systems.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(1e-10, 2, 2))
b = BallVector([5.0, 4.0], fill(1e-10, 2))

result = verified_linear_solve_hmatrix(A, b; method=:improved_method_a)

println(&quot;Verified: &quot;, result.verified)
println(&quot;Solution: &quot;, result.x_approx)
println(&quot;Error bound: &quot;, result.error_bound)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/verified_linear_system_hmatrix.jl#L39-L83">source</a></section></details></article><h2 id="Sylvester-Equations"><a class="docs-heading-anchor" href="#Sylvester-Equations">Sylvester Equations</a><a id="Sylvester-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Sylvester-Equations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.sylvester_miyajima_enclosure"><a class="docstring-binding" href="#BallArithmetic.sylvester_miyajima_enclosure"><code>BallArithmetic.sylvester_miyajima_enclosure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sylvester_miyajima_enclosure(A, B, C, X̃)</code></pre><p>Compute a Miyajima-style verified enclosure for the solution of the Sylvester problem <code>A * X + X * B = C</code>.  The method follows the componentwise certificate from Ref. [<a href="../../references/#MiyajimaSylvester2013">3</a>] and returns a <code>BallMatrix</code> whose midpoint is the supplied approximation <code>X̃</code> and whose radii enclose the exact solution entrywise.</p><p>The routine raises an error when the spectral gaps <code>λ_i(A) + λ_j(B)</code> vanish or when the contraction bound is not satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/sylvester.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.triangular_sylvester_miyajima_enclosure"><a class="docstring-binding" href="#BallArithmetic.triangular_sylvester_miyajima_enclosure"><code>BallArithmetic.triangular_sylvester_miyajima_enclosure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">triangular_sylvester_miyajima_enclosure(T, k)</code></pre><p>Construct the Miyajima enclosure for the Sylvester system associated with the upper-triangular matrix <code>T</code> partitioned as</p><pre><code class="language-julia hljs">T = [T₁₁  T₁₂;
     0    T₂₂],</code></pre><p>where <code>T₁₁</code> is <code>k × k</code>.  The enclosure is computed for the solution <code>Y₂</code> of the transformed Sylvester equation <code>T₂₂&#39; * Y₂ - Y₂ * T₁₁&#39; = T₁₂&#39;</code>.  Forming the standard Sylvester data <code>A = T₂₂&#39;</code>, <code>B = -T₁₁&#39;</code>, and <code>C = T₁₂&#39;</code>, the routine solves for an approximate <code>Y₂</code> and then calls <a href="#BallArithmetic.sylvester_miyajima_enclosure"><code>sylvester_miyajima_enclosure</code></a> to obtain a verified bound.  The returned <code>BallMatrix</code> encloses the exact <code>Y₂</code> entrywise.</p><p>The matrix <code>T</code> must be square and upper triangular, and the block size <code>k</code> must satisfy <code>1 ≤ k &lt; size(T, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/sylvester.jl#L178-L198">source</a></section><section><div><pre><code class="language-julia hljs">triangular_sylvester_miyajima_enclosure(T_ball::BallMatrix, k::Integer)</code></pre><p>Miyajima enclosure for the Sylvester system when the triangular matrix <code>T</code> is given as a <code>BallMatrix</code> (midpoint + radii).</p><p>The midpoint <code>mid(T_ball)</code> is used to solve the Sylvester equation via the scalar method. The radii of <code>T_ball</code> produce a first-order perturbation bound on the solution <code>Y</code>, which inflates the returned enclosure.</p><p><strong>Algorithm</strong></p><ol><li>Solve on midpoint: <code>Y_mid = triangular_sylvester_miyajima_enclosure(mid(T_ball), k)</code></li><li>Compute separation: <code>sep = min_{i,j} |T₁₁[i,i] - T₂₂[j,j]|</code> (lower-bounded rigorously)</li><li>First-order perturbation bound on Y from T<em>ball radii: <code>δY ≤ sep⁻¹ · (‖ΔT₂₂‖·‖Y‖ + ‖ΔT₁₁‖·‖Y‖ + ‖ΔT₁₂‖)</code> where `ΔT</em>ij` are the radius sub-blocks</li><li>Inflate: <code>BallMatrix(mid(Y_mid), rad(Y_mid) .+ δY)</code></li></ol><p>The matrix <code>T_ball</code> must be square, and <code>mid(T_ball)</code> must be upper triangular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/linear_system/sylvester.jl#L228-L247">source</a></section></details></article><h2 id="Matrix-Regularity"><a class="docs-heading-anchor" href="#Matrix-Regularity">Matrix Regularity</a><a id="Matrix-Regularity-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Regularity" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.RegularityResult"><a class="docstring-binding" href="#BallArithmetic.RegularityResult"><code>BallArithmetic.RegularityResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RegularityResult{T}</code></pre><p>Result from regularity testing.</p><p><strong>Fields</strong></p><ul><li><code>is_regular::Bool</code>: True if proven regular, false if inconclusive</li><li><code>method::Symbol</code>: Method used for testing</li><li><code>certificate::T</code>: Numerical certificate (e.g., separation value)</li><li><code>is_definitive::Bool</code>: Whether result is definitive or just sufficient condition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/regularity.jl#L15-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.is_regular"><a class="docstring-binding" href="#BallArithmetic.is_regular"><code>BallArithmetic.is_regular</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_regular(A::BallMatrix{T};
          methods::Vector{Symbol}=[:sufficient_condition, :gershgorin, :diagonal_dominance],
          verbose::Bool=false) where {T}</code></pre><p>Test regularity using multiple methods.</p><p>Tries several sufficient conditions in order until one succeeds.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li><li><code>methods</code>: Vector of methods to try (in order)</li><li><code>verbose</code>: Print information about each method</li></ul><p><strong>Available Methods</strong></p><ul><li><code>:sufficient_condition</code>: Eigenvalue-based (Theorem 11.12)</li><li><code>:gershgorin</code>: Gershgorin circle theorem</li><li><code>:diagonal_dominance</code>: Strict diagonal dominance</li></ul><p><strong>Returns</strong></p><p><code>RegularityResult</code> from first successful method, or last result if all fail.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 0.5; 0.5 2.0], fill(0.1, 2, 2))

result = is_regular(A, verbose=true)

if result.is_regular
    println(&quot;Matrix is regular (proven by &quot;, result.method, &quot;)&quot;)
else
    println(&quot;Regularity could not be proven&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>Tries multiple sufficient conditions</li><li>Returns true only if regularity is proven</li><li>False result is inconclusive (matrix may still be regular)</li><li>Order methods by speed: diagonal<em>dominance → gershgorin → sufficient</em>condition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/regularity.jl#L256-L296">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.is_regular_sufficient_condition"><a class="docstring-binding" href="#BallArithmetic.is_regular_sufficient_condition"><code>BallArithmetic.is_regular_sufficient_condition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_regular_sufficient_condition(A::BallMatrix{T}) where {T}</code></pre><p>Test regularity using sufficient condition from Theorem 11.12 (Horáček, p. 183).</p><p><strong>Sufficient Condition</strong></p><p>Matrix [A] is regular if:     λ<em>max(A</em>Δ^T A<em>Δ) &lt; λ</em>min(A<em>c^T A</em>c)</p><p>where A<em>c is center and A</em>Δ is radius matrix.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li></ul><p><strong>Returns</strong></p><p><code>RegularityResult</code> with test outcome.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(0.05, 2, 2))

result = is_regular_sufficient_condition(A)

if result.is_regular
    println(&quot;Matrix is proven regular&quot;)
    println(&quot;Separation: &quot;, result.certificate)
else
    println(&quot;Test inconclusive&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>O(n³) complexity (eigenvalue computation)</li><li>Sufficient but not necessary</li><li>If returns true, regularity is guaranteed</li><li>If returns false, matrix may still be regular</li><li>Works well for small radius matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/regularity.jl#L37-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.is_regular_gershgorin"><a class="docstring-binding" href="#BallArithmetic.is_regular_gershgorin"><code>BallArithmetic.is_regular_gershgorin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_regular_gershgorin(A::BallMatrix{T}) where {T}</code></pre><p>Test regularity using Gershgorin circle theorem.</p><p><strong>Gershgorin Criterion</strong></p><p>Matrix [A] is regular if for all i, 0 is not in the Gershgorin disc:     D<em>i = {z : |z - a</em>{ii}| ≤ ∑<em>{j≠i} |a</em>{ij}|}</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li></ul><p><strong>Returns</strong></p><p><code>RegularityResult</code> with test outcome.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([4.0 1.0 0.5; 0.5 3.0 0.5; 0.5 0.5 2.0], fill(0.1, 3, 3))

result = is_regular_gershgorin(A)

if result.is_regular
    println(&quot;Matrix is proven regular by Gershgorin&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>O(n²) complexity - very fast</li><li>Sufficient but not necessary</li><li>Works well for diagonally dominant matrices</li><li>Conservative for general matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/regularity.jl#L108-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.is_regular_diagonal_dominance"><a class="docstring-binding" href="#BallArithmetic.is_regular_diagonal_dominance"><code>BallArithmetic.is_regular_diagonal_dominance</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_regular_diagonal_dominance(A::BallMatrix{T};
                              strict::Bool=true) where {T}</code></pre><p>Test regularity using diagonal dominance.</p><p><strong>Criterion</strong></p><p>Matrix [A] is regular if it is strictly diagonally dominant:     |a<em>{ii}| &gt; ∑</em>{j≠i} |a_{ij}|  for all i</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li><li><code>strict</code>: Require strict (&gt;) or weak (≥) diagonal dominance</li></ul><p><strong>Returns</strong></p><p><code>RegularityResult</code> with test outcome.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([5.0 1.0 1.0; 1.0 4.0 0.5; 0.5 1.0 3.0], fill(0.1, 3, 3))

result = is_regular_diagonal_dominance(A)

if result.is_regular
    println(&quot;Matrix is strictly diagonally dominant&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>O(n²) complexity</li><li>Very fast test</li><li>Sufficient for regularity</li><li>Many practical matrices satisfy this</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/regularity.jl#L182-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.is_singular_sufficient_condition"><a class="docstring-binding" href="#BallArithmetic.is_singular_sufficient_condition"><code>BallArithmetic.is_singular_sufficient_condition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_singular_sufficient_condition(A::BallMatrix{T}) where {T}</code></pre><p>Test singularity using sufficient condition from Theorem 11.13 (Horáček, p. 183).</p><p><strong>Sufficient Condition for Singularity</strong></p><p>Matrix [A] contains at least one singular matrix if:     λ<em>min(A</em>c^T A<em>c) &lt; λ</em>max(A<em>Δ^T A</em>Δ)</p><p>This is the dual of the regularity condition.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li></ul><p><strong>Returns</strong></p><p><code>true</code> if proven singular, <code>false</code> if inconclusive.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([1.0 1.0; 1.0 1.0], fill(0.05, 2, 2))

if is_singular_sufficient_condition(A)
    println(&quot;Matrix contains singular matrices&quot;)
end</code></pre><p><strong>Notes</strong></p><ul><li>O(n³) complexity</li><li>Sufficient but not necessary</li><li>Dual of regularity test</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/regularity.jl#L336-L366">source</a></section></details></article><h2 id="Determinant-Bounds"><a class="docs-heading-anchor" href="#Determinant-Bounds">Determinant Bounds</a><a id="Determinant-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Determinant-Bounds" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BallArithmetic.DeterminantResult"><a class="docstring-binding" href="#BallArithmetic.DeterminantResult"><code>BallArithmetic.DeterminantResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DeterminantResult{T}</code></pre><p>Result from interval determinant computation.</p><p><strong>Fields</strong></p><ul><li><code>determinant::Ball{T}</code>: Enclosure of determinant</li><li><code>method::Symbol</code>: Method used</li><li><code>computation_time::T</code>: Time spent (optional)</li><li><code>tight::Bool</code>: Whether enclosure is known to be tight</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/determinant.jl#L15-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.interval_det"><a class="docstring-binding" href="#BallArithmetic.interval_det"><code>BallArithmetic.interval_det</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interval_det(A::BallMatrix{T};
            method::Symbol=:auto,
            check_regularity::Bool=true) where {T}</code></pre><p>Compute interval determinant enclosure using specified or automatic method.</p><p><strong>Methods</strong></p><ul><li><code>:auto</code>: Choose automatically based on matrix size and properties</li><li><code>:hadamard</code>: Hadamard inequality (fast, conservative)</li><li><code>:gershgorin</code>: Gershgorin-based bounds (fast, moderate)</li><li><code>:gaussian_elimination</code>: Gaussian elimination (moderate speed, good accuracy)</li><li><code>:cramer</code>: Cramer&#39;s rule (slow, exact for small n)</li></ul><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li><li><code>method</code>: Computation method</li><li><code>check_regularity</code>: First check if matrix is regular</li></ul><p><strong>Returns</strong></p><p><code>DeterminantResult</code> with determinant enclosure.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 1.0; 1.0 2.0], fill(0.1, 2, 2))

# Automatic method selection
result = interval_det(A)
println(&quot;det(A) ∈ &quot;, result.determinant)

# Specific method
result_hadamard = interval_det(A, method=:hadamard)</code></pre><p><strong>Notes</strong></p><ul><li>Auto mode chooses:<ul><li>Cramer for n ≤ 3</li><li>Gaussian elimination for n ≤ 20</li><li>Hadamard for n &gt; 20</li></ul></li><li>Check regularity first to avoid wasted computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/determinant.jl#L259-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.det_hadamard"><a class="docstring-binding" href="#BallArithmetic.det_hadamard"><code>BallArithmetic.det_hadamard</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">det_hadamard(A::BallMatrix{T}) where {T}</code></pre><p>Compute determinant bound using Hadamard&#39;s inequality.</p><p><strong>Hadamard&#39;s Inequality</strong></p><p>For any n×n matrix A:     |det(A)| ≤ ∏<em>{i=1}^n ||a</em>i||</p><p>where a_i is the i-th row of A.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li></ul><p><strong>Returns</strong></p><p><code>DeterminantResult</code> with determinant bounds.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0; 1.0 2.0], fill(0.1, 2, 2))

result = det_hadamard(A)
println(&quot;det(A) ∈ &quot;, result.determinant)</code></pre><p><strong>Notes</strong></p><ul><li>O(n²) complexity - very fast</li><li>Provides only upper bound on |det(A)|</li><li>Very conservative for most matrices</li><li>Useful for quick nonsingularity check</li><li>Not tight except for special cases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/determinant.jl#L37-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.det_gershgorin"><a class="docstring-binding" href="#BallArithmetic.det_gershgorin"><code>BallArithmetic.det_gershgorin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">det_gershgorin(A::BallMatrix{T}) where {T}</code></pre><p>Compute determinant bound using Gershgorin circle theorem.</p><p><strong>Gershgorin Approach</strong></p><p>Eigenvalues lie in union of Gershgorin discs:     λ<em>i ∈ {z : |z - a</em>{ii}| ≤ ∑<em>{j≠i} |a</em>{ij}|}</p><p>Determinant is product of eigenvalues.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Interval matrix (n×n)</li></ul><p><strong>Returns</strong></p><p><code>DeterminantResult</code> with determinant bounds.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([3.0 0.5; 0.5 2.0], fill(0.1, 2, 2))

result = det_gershgorin(A)
println(&quot;det(A) ∈ &quot;, result.determinant)</code></pre><p><strong>Notes</strong></p><ul><li>O(n²) complexity - fast</li><li>Can provide tighter bounds than Hadamard for diagonally dominant matrices</li><li>Conservative for general matrices</li><li>Uses product of disc bounds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/determinant.jl#L94-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.det_cramer"><a class="docstring-binding" href="#BallArithmetic.det_cramer"><code>BallArithmetic.det_cramer</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">det_cramer(A::BallMatrix{T}) where {T}</code></pre><p>Compute determinant using Cramer&#39;s rule (cofactor expansion).</p><p><strong>Warning</strong></p><p>This method has O(n!) complexity and should only be used for n ≤ 4.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Small interval matrix (n ≤ 4)</li></ul><p><strong>Returns</strong></p><p><code>DeterminantResult</code> with exact interval determinant.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([2.0 1.0; 1.0 3.0], fill(0.05, 2, 2))

result = det_cramer(A)
println(&quot;det(A) ∈ &quot;, result.determinant)  # Exact result</code></pre><p><strong>Notes</strong></p><ul><li>O(n!) complexity - only for tiny matrices</li><li>Provides exact interval arithmetic result</li><li>Tight enclosure (no overestimation from method)</li><li>Wrapping effect still present</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/determinant.jl#L170-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BallArithmetic.contains_zero"><a class="docstring-binding" href="#BallArithmetic.contains_zero"><code>BallArithmetic.contains_zero</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">contains_zero(det_result::DeterminantResult{T}) where {T}</code></pre><p>Check if determinant enclosure contains zero (possible singularity).</p><p><strong>Arguments</strong></p><ul><li><code>det_result</code>: Result from determinant computation</li></ul><p><strong>Returns</strong></p><p><code>true</code> if 0 ∈ det(A), <code>false</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = BallMatrix([1.0 1.0; 1.0 1.0], fill(0.1, 2, 2))
result = interval_det(A)

if contains_zero(result)
    println(&quot;Matrix may be singular&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaBallArithmetic/BallArithmetic.jl/blob/e0058942dab8f6e6e5fdf4d76d94450d406da20d/src/matrix_properties/determinant.jl#L353-L373">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../core/">« Core Types</a><a class="docs-footer-nextpage" href="../eigenvalues/">Eigenvalues &amp; SVD »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 22:49">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
